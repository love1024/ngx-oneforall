# ngx-oneforall — Full Documentation

> A collection of 85+ high-quality Angular utilities designed to solve common development challenges.
> Tree-shakable, zero-dependency, SSR-ready, and fully tested with 100% coverage.

---

# Getting Started

## Installation

**URL**: https://love1024.github.io/ngx-oneforall/getting-started/installation
**Import**: `ngx-oneforall/getting-started/installation`

Install the library via npm or yarn:

```bash
npm install ngx-oneforall
```

Or

```bash
yarn add ngx-oneforall
```

## Optional Dependencies

For phone validator, install:

```bash
npm install libphonenumber-js
```

## Requirements

- **Angular**: 17.1+ / 18.x / 19.x / 20.x / 21.x
- **RxJS**: 7.x or 8.x

# Usage

**ngx-oneforall** is modular by design. Import only what you need from its specific path.

### Example

```typescript
import { Component } from '@angular/core';
import { TruncatePipe } from 'ngx-oneforall/pipes/truncate';
import { ClickOutsideDirective } from 'ngx-oneforall/directives/click-outside';
import { CacheService } from 'ngx-oneforall/services/cache';

@Component({
  selector: 'app-component',
  templateUrl: 'app.component.html',
  standalone: true,
  imports: [TruncatePipe, ClickOutsideDirective],
  providers: [CacheService]
})
export class AppComponent {
}
```

Since the library is tree-shakable, only the features you actually import will be included in your final bundle.

# Troubleshooting

If you run into issues:
1. Check that your Angular version is compatible.
2. Try clearing your `node_modules` and reinstalling.
3. Check for any peer dependency warnings during installation.

## Introduction

**URL**: https://love1024.github.io/ngx-oneforall/getting-started/introduction
**Import**: `ngx-oneforall/getting-started/introduction`

**ngx-oneforall** is a collection of 80+ high-quality Angular utilities designed to solve common development challenges. Instead of reinventing the wheel or managing dozens of small dependencies, you get a unified toolkit that just works.

![Project Image](/ngx-oneforall/assets/brand.png)

> **One For All** - A single library providing the essential blocks for modern Angular development.


# Key Features

### Performance & Efficiency
Every utility is written from scratch and optimized specifically for Angular. We prioritize memory efficiency and runtime performance rather than just wrapping existing heavy libraries. Maximum size of a utility is 3kb gzipped.

### Modular & Tree-shakable
Import only what you use. The library is fully tree-shakable, so adding one utility doesn't bloat your bundle with the rest of the library.

### Zero Dependencies
We keep the dependency tree clean. **ngx-oneforall** has **NO third-party dependencies** (except `libphonenumber-js` for the phone validator). This reduces security risks, simplifies updates, and prevents version conflicts.

### First-Class SSR Support
Built for modern hydration. Every component and utility is designed to work seamlessly in Server-Side Rendering (SSR) environments out of the box.

### 100% Test Coverage
We take reliability seriously. The entire library is fully covered by tests to ensure edge cases are handled and behavior remains consistent across updates.

### Built for Modern Angular
Designed with **Signals** and **Standalone Components** in mind. This isn't a legacy port—it's built for the current and future state of Angular.

---

# Why Use It?

### Stop Re-writing Utilities
Avoid copy-pasting the same regex patterns, validators, and helper functions between projects. Use a standardized, tested set of utilities instead.

### Focus on Business Logic
Don't waste time maintaining generic boilerplate code. Use these proven primitives to build your actual application features faster.

### Better Developer Experience
Fully typed APIs and consistent behavior make these utilities predictable and easy to work with. You get strict typing and comprehensive documentation right in your IDE.

---

# Available Utilities

| Category | Utilities |
|----------|-----------|
| **Constants** | `breakpoints`, `device`, `file-extension`, `host-platforms`, `http`, `key`, `regex`, `sort-direction`, `time`, `types` |
| **Decorators** | `cache`, `catch-error`, `debounce`, `log-execution-time`, `memoize`, `only-in-browser`, `throttle` |
| **Directives** | `auto-focus`, `click-outside`, `click-throttle`, `hover-class`, `infinite-scroll`, `numbers-only`, `press-enter`, `repeat`, `resized`, `shortcut`, `typed-template`, `visibility-change` |
| **Guards** | `param`, `query-param`, `unsaved-changes` |
| **Interceptors** | `base-url`, `cache`, `correlation-id`, `encryption`, `jwt`, `performance`, `timeout` |
| **Pipes** | `bytes`, `call`, `first-error-key`, `highlight-search`, `initials`, `pluralize`, `range`, `safe-html`, `time-ago`, `truncate` |
| **Rxjs** | `backoff-retry`, `catch-error-with-fallback`, `data-polling`, `debug`, `live-search`, `loading-status` |
| **Services** | `cache`, `clipboard`, `cookie`, `device`, `event`, `history`, `idle`, `jwt`, `logger`, `network-status`, `shortcut`, `storage` |
| **Signals** | `breakpoint-matcher`, `debounced-signal`, `deep-computed`, `event-signal`, `interval-signal`, `route-param-signal`, `route-query-param-signal`, `router-event-signal`, `state-signal`, `storage-signal`, `throttled-signal`, `websocket-signal` |
| **Utils** | `base64`, `download-link`, `find-type`, `hash`, `host-platform`, `is-key-defined`, `is-number`, `is-present`, `is-record`, `normalize-key`, `safe-await`, `safe-serialize`, `unique-component-id` |
| **Validators** | `credit-card`, `date`, `match-field`, `max-date`, `min-date`, `min-length-trimmed`, `not-blank`, `number`, `phone`, `range`, `range-length`, `url` |

---

# Issues & Feature Requests

Found a bug or edge case? Have an idea for a new utility? We'd love to hear from you!

- **Report Issues**: If you encounter any bugs or unexpected behavior, please [open an issue](https://github.com/love1024/ngx-oneforall/issues).
- **Feature Requests**: Have a utility in mind that would benefit the community? Submit a feature request via [GitHub Issues](https://github.com/love1024/ngx-oneforall/issues).

## LLMs.txt

**URL**: https://love1024.github.io/ngx-oneforall/getting-started/llms
**Import**: `ngx-oneforall/getting-started/llms`

LLM-optimized documentation endpoints for ngx-oneforall utilities.

The [llms.txt](https://llmstxt.org/) standard helps AI models better understand and navigate documentation. ngx-oneforall provides two files that follow this standard.

---

## /llms.txt

The `llms.txt` file is a structured index of all ngx-oneforall utilities. It lists every page with a title, link, and short description — making it easy for LLMs to find relevant documentation.

[Open llms.txt](https://love1024.github.io/ngx-oneforall/llms.txt)

---

## /llms-full.txt

The `llms-full.txt` file contains the **complete documentation** for all utilities in a single file. Use this when you want an LLM to have full context about the entire library.

[Open llms-full.txt](https://love1024.github.io/ngx-oneforall/llms-full.txt)

---

## Regenerating

If you update documentation pages and need to regenerate the LLMs files, run:

```bash
npm run generate:llms
```

This reads all `ng-doc.page.ts` and `index.md` files and produces both `llms.txt` and `llms-full.txt` in the `public/` directory.

---

# Constants

## Breakpoints

**URL**: https://love1024.github.io/ngx-oneforall/constants/breakpoints
**Import**: `ngx-oneforall/constants/breakpoints`

The `ngx-oneforall/constants` package provides a set of constants for responsive design breakpoints, including their names, numeric values, and CSS media query strings.

## Usage

Import the constants to handle responsive logic in your components or services.

```typescript
import { BREAKPOINT, BREAKPOINT_QUERY } from 'ngx-oneforall/constants';

// Example: Using a media query in a component
const isMobileQuery = BREAKPOINT_QUERY[BREAKPOINT.XS];

// Example: Comparing against a breakpoint value
if (window.innerWidth >= BREAKPOINT_VALUE.MD) {
  // Logic for tablet and above
}
```

## BREAKPOINT

The `BREAKPOINT` constant defines the names of the support breakpoints.

| Name | Value |
| :--- | :--- |
| **XS** | `'xs'` |
| **SM** | `'sm'` |
| **MD** | `'md'` |
| **LG** | `'lg'` |
| **XL** | `'xl'` |
| **XXL** | `'xxl'` |
| **SM_ONLY** | `'smOnly'` |
| **MD_ONLY** | `'mdOnly'` |
| **LG_ONLY** | `'lgOnly'` |
| **XL_ONLY** | `'xlOnly'` |

## BREAKPOINT_VALUE

Numeric pixel values for each breakpoint threshold.

| Name | Value (px) |
| :--- | :--- |
| **XS** | `0` |
| **SM** | `576` |
| **MD** | `768` |
| **LG** | `992` |
| **XL** | `1200` |
| **XXL** | `1400` |

## BREAKPOINT_QUERY

Standardized CSS media query strings for each breakpoint.

| Breakpoint | Media Query |
| :--- | :--- |
| **XS** | `(max-width: 575.98px)` |
| **SM** | `(min-width: 576px)` |
| **MD** | `(min-width: 768px)` |
| **LG** | `(min-width: 992px)` |
| **XL** | `(min-width: 1200px)` |
| **XXL** | `(min-width: 1400px)` |
| **SM_ONLY**| `(min-width: 576px) and (max-width: 767.98px)` |
| **MD_ONLY**| `(min-width: 768px) and (max-width: 991.98px)` |
| **LG_ONLY**| `(min-width: 992px) and (max-width: 1199.98px)` |
| **XL_ONLY**| `(min-width: 1200px) and (max-width: 1399.98px)` |

## Device

**URL**: https://love1024.github.io/ngx-oneforall/constants/device
**Import**: `ngx-oneforall/constants/device`

The `ngx-oneforall/constants` package provides a constant for categorizing devices by type, which is useful for conditional logic based on the platform.

## Usage

Import the `DEVICE_TYPE` constant to use in your components or services.

```typescript
import { DEVICE_TYPE } from 'ngx-oneforall/constants';

// Example: Handling logic based on device type
if (currentDevice() === DEVICE_TYPE.Mobile) {
  // Mobile specific logic
}
```

## DEVICE_TYPE

| Name | Value |
| :--- | :--- |
| **Mobile** | `'mobile'` |
| **Tablet** | `'tablet'` |
| **Desktop** | `'desktop'` |

## File Extension

**URL**: https://love1024.github.io/ngx-oneforall/constants/file-extension
**Import**: `ngx-oneforall/constants/file-extension`

The `ngx-oneforall/constants` package provides a comprehensive set of common file extensions. These constants are useful for file type validation, filtering, and handling file uploads.

## Usage

Import the `FILE_EXTENSION` constant to use in your file handling logic.

```typescript
import { FILE_EXTENSION } from 'ngx-oneforall/constants';

// Example: Checking if a file is an image
const isImage = [
  FILE_EXTENSION.PNG,
  FILE_EXTENSION.JPG,
  FILE_EXTENSION.JPEG,
  FILE_EXTENSION.GIF,
  FILE_EXTENSION.WEBP
].includes(fileExtension.toLowerCase());

// Example: Restricting file upload to documents
const acceptedDocs = `${FILE_EXTENSION.PDF},${FILE_EXTENSION.DOCX},${FILE_EXTENSION.XLSX}`;
```

## FILE_EXTENSION

### Images

| Name | Value |
| :--- | :--- |
| **PNG** | `'png'` |
| **JPG** | `'jpg'` |
| **JPEG** | `'jpeg'` |
| **GIF** | `'gif'` |
| **WEBP** | `'webp'` |
| **SVG** | `'svg'` |

### Documents

| Name | Value |
| :--- | :--- |
| **PDF** | `'pdf'` |
| **DOC** | `'doc'` |
| **DOCX** | `'docx'` |
| **XLS** | `'xls'` |
| **XLSX** | `'xlsx'` |
| **CSV** | `'csv'` |
| **TXT** | `'txt'` |
| **RTF** | `'rtf'` |

### Presentations

| Name | Value |
| :--- | :--- |
| **PPT** | `'ppt'` |
| **PPTX** | `'pptx'` |

### Archives

| Name | Value |
| :--- | :--- |
| **ZIP** | `'zip'` |
| **RAR** | `'rar'` |
| **TAR** | `'tar'` |
| **GZ** | `'gz'` |
| **_7Z** | `'7z'` |

### Audio

| Name | Value |
| :--- | :--- |
| **MP3** | `'mp3'` |
| **WAV** | `'wav'` |
| **AAC** | `'aac'` |
| **FLAC** | `'flac'` |
| **OGG** | `'ogg'` |

### Video

| Name | Value |
| :--- | :--- |
| **MP4** | `'mp4'` |
| **WEBM** | `'webm'` |
| **MKV** | `'mkv'` |
| **AVI** | `'avi'` |
| **MOV** | `'mov'` |

## Host Platforms

**URL**: https://love1024.github.io/ngx-oneforall/constants/host-platforms
**Import**: `ngx-oneforall/constants/host-platforms`

---
keyword: HostPlatformsPage
---

The `HostPlatform` enum defines the supported host platforms (operating systems) that can be detected by the `getHostPlatform` utility.

## Usage

Import `HostPlatform` from `ngx-oneforall`:

```typescript
import {HostPlatform} from 'ngx-oneforall/constants';

// Usage with getHostPlatform
const platform = getHostPlatform();

if (platform === HostPlatform.MAC) {
    // macOS specific logic
}
```

## Enum Values

| Member | Value | Description |
|--------|-------|-------------|
| `MAC` | `'MAC'` | macOS |
| `IOS` | `'IOS'` | iOS (iPhone, iPad, iPod) |
| `WINDOWS` | `'WINDOWS'` | Windows |
| `WINDOWS_PHONE` | `'WINDOWS_PHONE'` | Windows Phone |
| `ANDROID` | `'ANDROID'` | Android |
| `LINUX` | `'LINUX'` | Linux |
| `UNKNOWN` | `'UNKNOWN'` | Unknown platform |

## HTTP

**URL**: https://love1024.github.io/ngx-oneforall/constants/http
**Import**: `ngx-oneforall/constants/http`

The `ngx-oneforall/constants` package provides sets of constants for common HTTP methods and headers. Using these constants helps prevent typos and improves code maintainability.

## Usage

Import the constants from the constants package and use them in your HTTP requests or interceptors.

```typescript
import { HTTP_METHOD, HTTP_HEADER } from 'ngx-oneforall/constants';

// In an interceptor or service
const headers = new HttpHeaders({
  [HTTP_HEADER.ContentType]: 'application/json',
  [HTTP_HEADER.Authorization]: `Bearer ${token}`
});

this.http.request(HTTP_METHOD.POST, url, { headers, body });
```

## HTTP Methods

The `HTTP_METHOD` constant includes standard HTTP verbs.

| Name | Value |
| :--- | :--- |
| **GET** | `'GET'` |
| **POST** | `'POST'` |
| **PUT** | `'PUT'` |
| **PATCH** | `'PATCH'` |
| **DELETE** | `'DELETE'` |
| **OPTIONS** | `'OPTIONS'` |
| **HEAD** | `'HEAD'` |

## HTTP Headers

The `HTTP_HEADER` constant includes commonly used HTTP header names.

| Name | Value |
| :--- | :--- |
| **Authorization** | `'Authorization'` |
| **ContentType** | `'Content-Type'` |
| **Accept** | `'Accept'` |
| **CacheControl** | `'Cache-Control'` |
| **IfNoneMatch** | `'If-None-Match'` |

## Keys

**URL**: https://love1024.github.io/ngx-oneforall/constants/keys
**Import**: `ngx-oneforall/constants/keys`

The `ngx-oneforall/constants` package provides sets of constants for keyboard keys and their corresponding numeric codes. These are useful for handling keyboard events in a type-safe way.

## Usage

You can use these constants when listening to keyboard events to avoid hardcoding strings or magic numbers.

```typescript
import { Key, KeyCode } from 'ngx-oneforall/constants';

// Using Key strings
if (event.key === Key.Enter) {
  // Handle enter key
}

// Using KeyCodes
if (event.keyCode === KeyCode.Enter) {
  // Handle enter key code
}
```

## Key Strings

The `Key` constant contains standard string values for keys, typically matching `event.key`.

| Name | Value |
| :--- | :--- |
| **Backspace** | `'Backspace'` |
| **Tab** | `'Tab'` |
| **Enter** | `'Enter'` |
| **Shift** | `'Shift'` |
| **Control** | `'Control'` |
| **Alt** | `'Alt'` |
| **Pause** | `'Pause'` |
| **CapsLock** | `'CapsLock'` |
| **Escape** | `'Escape'` |
| **Space** | `' '` |
| **PageUp** | `'PageUp'` |
| **PageDown** | `'PageDown'` |
| **End** | `'End'` |
| **Home** | `'Home'` |
| **ArrowLeft** | `'ArrowLeft'` |
| **ArrowUp** | `'ArrowUp'` |
| **ArrowRight** | `'ArrowRight'` |
| **ArrowDown** | `'ArrowDown'` |
| **Insert** | `'Insert'` |
| **Delete** | `'Delete'` |

### Numbers & Letters

Includes digits `0-9` (value matches digit) and letters `a-z` (lowercase).

### Function Keys

Includes `F1` through `F12`.

---

## Key Codes

The `KeyCode` constant contains the numeric values for keys, typically matching `event.keyCode`.

| Name | Code |
| :--- | :--- |
| **Backspace** | `8` |
| **Tab** | `9` |
| **Enter** | `13` |
| **Shift** | `16` |
| **Control** | `17` |
| **Alt** | `18` |
| **Pause** | `19` |
| **CapsLock** | `20` |
| **Escape** | `27` |
| **Space** | `32` |
| **PageUp** | `33` |
| **PageDown** | `34` |
| **End** | `35` |
| **Home** | `36` |
| **ArrowLeft** | `37` |
| **ArrowUp** | `38` |
| **ArrowRight** | `39` |
| **ArrowDown** | `40` |
| **Insert** | `45` |
| **Delete** | `46` |

### Numbers & Letters

- **Digits (0-9)**: Codes `48` to `57`.
- **Letters (A-Z)**: Codes `65` to `90`.

### Function Keys

- **F1-F12**: Codes `112` to `123`.

## Regex

**URL**: https://love1024.github.io/ngx-oneforall/constants/regex
**Import**: `ngx-oneforall/constants/regex`

The `ngx-oneforall/constants` package provides a set of common regular expressions for data validation. These constants help you maintain consistency and avoid duplicate regex definitions across your application.

## Usage

Import the `REGEX` constant to use in your validators or logic.

```typescript
import { REGEX } from 'ngx-oneforall/constants';

// Example: Using regex for manual validation
const value = '12345';
const isNumeric = REGEX.Numeric.test(value);

// Example: Using in an Angular FormControl validator (Pattern validator)
const control = new FormControl('', [Validators.pattern(REGEX.AlphaNumeric)]);
```

## REGEX

### Numeric

| Name | Regex | Description |
| :--- | :--- | :--- |
| **Numeric** | `/^\d+$/` | Matches one or more digits. |
| **Integer** | `/^-?\d+$/` | Matches positive or negative integers. |
| **Decimal** | `/^-?\d+(\.\d+)?$/` | Matches positive or negative decimal numbers. |
| **PositiveInteger** | `/^\d+$/` | Matches positive integers. |
| **NegativeInteger** | `/^-\d+$/` | Matches negative integers. |

### Alphabetic

| Name | Regex | Description |
| :--- | :--- | :--- |
| **Alpha** | `/^[a-zA-Z]+$/` | Matches alphabetic characters (case-insensitive). |
| **AlphaLower** | `/^[a-z]+$/` | Matches lowercase alphabetic characters. |
| **AlphaUpper** | `/^[A-Z]+$/` | Matches uppercase alphabetic characters. |
| **AlphaNumeric** | `/^[a-zA-Z0-9]+$/` | Matches alphabetic and numeric characters. |

## Sort Direction

**URL**: https://love1024.github.io/ngx-oneforall/constants/sort-direction
**Import**: `ngx-oneforall/constants/sort-direction`

The `ngx-oneforall/constants` package provides a constant for sort directions, helping you maintain consistency across your sorting logic.

## Usage

Import the `SORT_DIRECTION` constant to use in your sorting functions or components.

```typescript
import { SORT_DIRECTION } from 'ngx-oneforall/constants';

// Example: Handling sort change
function onSortChange(direction: 'asc' | 'desc') {
  if (direction === SORT_DIRECTION.Asc) {
    // Handle ascending sort
  } else {
    // Handle descending sort
  }
}
```

## SORT_DIRECTION

| Name | Value |
| :--- | :--- |
| **Asc** | `'asc'` |
| **Desc** | `'desc'` |

## Time

**URL**: https://love1024.github.io/ngx-oneforall/constants/time
**Import**: `ngx-oneforall/constants/time`

The `ngx-oneforall/constants` package provides a set of common time duration constants in milliseconds. These are useful for timeouts, intervals, and date manipulations.

## Usage

Import the `TIME` constant to use in your timers or logic.

```typescript
import { TIME } from 'ngx-oneforall/constants';

// Set an interval of one minute
setInterval(() => {
  console.log('One minute passed');
}, TIME.Minute);

// Calculate three hours in ms
const threeHours = 3 * TIME.Hour;
```

## TIME

All values are represented in **milliseconds**.

| Name | Milliseconds | Value |
| :--- | :--- | :--- |
| **Second** | `1,000` | `1000` |
| **Minute** | `60,000` | `60_000` |
| **Hour** | `3,600,000` | `3_600_000` |
| **Day** | `86,400,000` | `86_400_000` |
| **Week** | `604,800,000` | `604_800_000` |

## Types

**URL**: https://love1024.github.io/ngx-oneforall/constants/types
**Import**: `ngx-oneforall/constants/types`

=
The `Types` enum above provides a comprehensive list of possible JavaScript and TypeScript types, including primitives like `String` and `Number`, complex structures like `Map` and `Set`, as well as iterators and typed arrays. Using such enums can help with type checking, validation, and implementing utility functions that depend on type information.
``` typescript
export enum Types {
  Undefined = 'UNDEFINED',
  Null = 'NULL',
  Boolean = 'BOOLEAN',
  String = 'STRING',
  Number = 'NUMBER',
  Symbol = 'SYMBOL',
  Function = 'FUNCTION',
  Array = 'ARRAY',
  GeneratorFunction = 'GENERATOR_FUNCTION"',
  Unknown = 'UNKNOWN',
  Map = 'MAP',
  WeakMap = 'WEAK_MAP',
  Set = 'SET',
  WeakSet = 'WeakSet',
  Int8Array = 'INT8ARRAY',
  Uint8Array = 'UINT8ARRAY',
  Uint8ClampedArray = 'UINT8CLAMPEDARRAY',
  Int16Array = 'INT16ARRAY',
  Uint16Array = 'UINT16ARRAY',
  Int32Array = 'INT32ARRAY',
  Uint32Array = 'UINT32ARRAY',
  Float32Array = 'FLOAT32ARRAY',
  Float64Array = 'FLOAT64ARRAY',
  GeneratorObject = 'GENERATOR_OBJECT',
  Object = 'OBJECT',
  MapIterator = 'MAP_ITERATOR',
  SetIterator = 'SET_ITERATOR',
  StringIterator = 'STRING_ITERATOR',
  ArrayIterator = 'ARRAY_ITERATOR',
}
```

---

# Decorators

## Cache

**URL**: https://love1024.github.io/ngx-oneforall/decorators/cache
**Import**: `ngx-oneforall/decorators/cache`

The `Cache` decorator caches Observable method results with configurable storage, TTL, and versioning.

> **Note**
> **When to use:** Use `@Cache` for Observable methods. For sync or Promise methods, use [`@memoize`](/decorators/memoize) instead.

### Parameters

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `storage` | `'memory' \| 'local' \| 'session'` | `'memory'` | Storage backend |
| `storageKey` | `string` | `'CACHE_DECORATOR'` | Storage key for cache data |
| `ttl` | `number \| null` | `null` | Time-to-live in ms (`null` = no expiration) |
| `itemCacheKey` | `string` | Auto | Custom cache key for method |
| `maxItems` | `number \| null` | `null` | Max cached items (`null` = unlimited) |
| `version` | `string` | — | Cache version (change clears cache) |
| `cacheKeyMatcher` | `Function` | Deep compare | Custom param comparison |
| `cacheKeySelector` | `Function` | All params | Select params for cache key |

### Features

- **Multi-storage**: Memory, localStorage, sessionStorage
- **TTL expiration**: Auto-invalidate stale entries
- **Version control**: Clear cache on version change
- **Request deduplication**: Concurrent calls share same Observable
- **LRU eviction**: Limit cache size with `maxItems`
- **Error handling**: Failed requests are NOT cached

### Basic Usage

```typescript
@Injectable({ providedIn: 'root' })
export class UserService {
  @Cache({ ttl: 60000 })
  getUser(id: number): Observable<User> {
    return this.http.get<User>(`/api/users/${id}`);
  }
}
```

### With Storage & Max Items

```typescript
@Cache({ storage: 'local', maxItems: 10, ttl: 300000 })
searchUsers(query: string): Observable<User[]> {
  return this.http.get<User[]>(`/api/users?q=${query}`);
}
```

### Version Control

```typescript
@Cache({ version: '2.0.0', storage: 'session' })
getConfig(): Observable<Config> {
  return this.http.get<Config>('/api/config');
}
```

Changing `version` clears all cached data for this method.

### Custom Cache Key

```typescript
// Only use first param as cache key
@Cache({
  cacheKeySelector: (params) => params[0],
})
getData(id: number, timestamp: Date): Observable<Data> {
  return this.http.get<Data>(`/api/data/${id}`);
}
```

### Live Demonstration

## Catch Error

**URL**: https://love1024.github.io/ngx-oneforall/decorators/catch-error
**Import**: `ngx-oneforall/decorators/catch-error`

The `CatchError` decorator catches errors and provides fallback behavior for sync, Promise, and Observable methods.

### Parameters

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `fallback` | `unknown \| ((error) => unknown)` | `undefined` | Value or function to return on error |
| `logError` | `boolean` | `true` | Log errors to console |

### Features

- **Sync methods**: Wraps in try-catch
- **Promises**: Adds `.catch()` handler
- **Observables**: Pipes through `catchError`
- **Dynamic fallback**: Function receives error, can return dynamic value
- **Re-throw**: If `fallback` is undefined, error is re-thrown

### Basic Usage

```typescript
// Static fallback value
@CatchError([])
getUsers(): Observable<User[]> {
  return this.http.get<User[]>('/api/users');
}
```

### Dynamic Fallback

```typescript
// Fallback function receives error
@CatchError((err) => ({ error: true, message: err.message }))
async fetchData(): Promise<Data> {
  return await this.api.getData();
}
```

### Observable Fallback

```typescript
// Return Observable from fallback
@CatchError((err) => of({ fallback: true }))
getData(): Observable<any> {
  return throwError(() => new Error('fail'));
}
```

### Silent Errors

```typescript
// Disable console logging
@CatchError(null, false)
silentFetch(): Observable<any> { ... }
```

### Live Demonstration

## Debounce

**URL**: https://love1024.github.io/ngx-oneforall/decorators/debounce
**Import**: `ngx-oneforall/decorators/debounce`

The `debounce` decorator delays method execution until a specified time has passed since the last call. Supports leading/trailing edge execution.

### Parameters

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `options` | `number \| DebounceOptions` | `300` | Delay in ms or options object |
| `options.delay` | `number` | `300` | Delay in milliseconds |
| `options.leading` | `boolean` | `false` | Execute on first call (leading edge) |

### Features

- **Trailing edge** (default): Executes after delay elapses
- **Leading edge**: Executes immediately on first call
- **Return value caching**: Returns last result from original method
- **Instance isolation**: Each instance has its own debounced state

### Basic Usage

```typescript
@debounce(300)
onInputChange(event: Event): void {
  this.value = (event.target as HTMLInputElement).value;
}
```

### Leading Edge

Execute immediately on first call, then debounce:

```typescript
@debounce({ delay: 300, leading: true })
onButtonClick(): void {
  this.performAction();
}
```

### With Options Object

```typescript
@debounce({ delay: 500, leading: false })
onScroll(): void {
  this.updateScrollPosition();
}
```

### Comparison

| Mode | First Call | During Delay | After Delay |
|------|------------|--------------|-------------|
| `leading: false` | Schedules | Resets timer | Executes |
| `leading: true` | Executes | Resets timer | Resets state |

### Live Demonstration

## Log Execution Time

**URL**: https://love1024.github.io/ngx-oneforall/decorators/log-execution-time
**Import**: `ngx-oneforall/decorators/log-execution-time`

The `LogExecutionTime` decorator logs method execution time. Works with sync, Promise, and Observable methods.

### Parameters

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `label` | `string` | Method name | Custom label for log message |

### Output Format

```
[label] executed in X.XX ms
```

### Features

- **Sync methods**: Logs after return
- **Promises**: Logs after resolution/rejection
- **Observables**: Logs after completion via `finalize()`
- **Global disable**: Turn off logging for production

### Basic Usage

```typescript
@LogExecutionTime()
getData(): Observable<Data> {
  return this.http.get<Data>('/api/data');
}
// Console: [getData] executed in 123.45 ms
```

### Custom Label

```typescript
@LogExecutionTime('FetchUsers')
async getUsers(): Promise<User[]> {
  return await this.api.fetchUsers();
}
// Console: [FetchUsers] executed in 456.78 ms
```

### Disable in Production

```typescript
import { disableLogExecutionTime } from 'ngx-oneforall/decorators/log-execution-time';

// main.ts
if (environment.production) {
  disableLogExecutionTime();
}
```

### Helper Functions

| Function | Description |
|----------|-------------|
| `disableLogExecutionTime()` | Disables logging globally |
| `enableLogExecutionTime()` | Re-enables logging |
| `isLogExecutionTimeEnabled()` | Returns current enabled state |

### Live Demonstration

## Memoize

**URL**: https://love1024.github.io/ngx-oneforall/decorators/memoize
**Import**: `ngx-oneforall/decorators/memoize`

The `@memoize` decorator caches method results based on arguments. Works with sync and Promise methods.

> **Note**
> **When to use:** Use `@memoize` for sync or Promise methods. For Observable methods, use [`@Cache`](/decorators/cache) instead.

### Parameters

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `resolver` | `(...args) => string` | `safeSerialize` | Custom cache key function |
| `maxSize` | `number` | `undefined` | Max cache entries (LRU eviction) |

### Features

- **Sync and Promise support** - Caches both method returns and promise resolutions
- **Per-instance caching** - No shared state between instances
- **Custom key resolver** - Use object IDs instead of full serialization
- **Max cache size** - Limit cache with LRU eviction

### Basic Usage

```typescript
import { memoize } from 'ngx-oneforall/decorators/memoize';

@memoize()
factorial(n: number): number {
  if (n <= 1) return 1;
  return n * this.factorial(n - 1);
}
```

### Async Support

```typescript
@memoize()
fetchUser(id: string): Promise<User> {
  return this.http.get<User>(`/api/users/${id}`).toPromise();
}
// Second call returns cached promise
```

### Custom Resolver

```typescript
@memoize({ resolver: (user: User) => user.id })
processUser(user: User) {
  // Uses user.id as cache key instead of full serialization
}
```

### Max Cache Size

```typescript
@memoize({ maxSize: 100 })
compute(input: string): number {
  // Cache limited to 100 entries, oldest evicted first
}
```

### Best Practices

- **Pure methods only** - Don't use on methods with side effects
- **Use maxSize for large caches** - Prevent memory leaks
- **Use resolver for objects with IDs** - Faster than serialization

### Live Demonstration

## Only In Browser

**URL**: https://love1024.github.io/ngx-oneforall/decorators/only-in-browser
**Import**: `ngx-oneforall/decorators/only-in-browser`

The `OnlyInBrowser` decorator ensures methods only execute in browser environment, not during SSR.

### Parameters

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `fallback` | `T` | `undefined` | Value to return when not in browser |

### Features

- **SSR-safe** - Prevents browser-specific code from running on server
- **Fallback support** - Return custom value during SSR
- **Zero config** - Works without options for void methods

### Basic Usage

```typescript
import { OnlyInBrowser } from 'ngx-oneforall/decorators/only-in-browser';

@OnlyInBrowser()
initLocalStorage(): void {
  localStorage.setItem('initialized', 'true');
}
```

### With Fallback

```typescript
@OnlyInBrowser({ fallback: [] })
getFromStorage(): string[] {
  return JSON.parse(localStorage.getItem('items') || '[]');
}
// Returns [] during SSR instead of undefined
```

### Observable Fallback

```typescript
@OnlyInBrowser({ fallback: of([]) })
getBrowserData(): Observable<Data[]> {
  // Uses browser-only APIs
}
// Returns of([]) during SSR
```

### Use Cases

- Accessing `window` or `document`
- DOM manipulation
- Browser storage (localStorage, sessionStorage)
- Browser-only libraries

### Live Demonstration

## Throttle

**URL**: https://love1024.github.io/ngx-oneforall/decorators/throttle
**Import**: `ngx-oneforall/decorators/throttle`

The `throttle` decorator limits method execution to once per delay period. Unlike debounce, it executes immediately.

### Parameters

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `delay` | `number` | `300` | Delay in milliseconds |
| `leading` | `boolean` | `true` | Execute on leading edge |
| `trailing` | `boolean` | `false` | Execute on trailing edge |

### Features

- **Leading edge** - Executes immediately (default)
- **Trailing edge** - Optional execution after delay
- **Per-instance** - Separate throttle state per instance
- **Cached return** - Returns last result during throttle period

### Basic Usage

```typescript
import { throttle } from 'ngx-oneforall/decorators/throttle';

@throttle(500)
handleScroll() {
  // Executes at most once per 500ms
}
```

### With Trailing Edge

```typescript
@throttle({ delay: 500, trailing: true })
savePosition() {
  // Executes on first call AND after 500ms with latest args
}
```

### Trailing Only

```typescript
@throttle({ delay: 1000, leading: false, trailing: true })
batchUpdates() {
  // Waits 1000ms, then executes with latest args
}
```

### Use Cases

- Scroll event handlers
- Window resize handlers
- Rate-limiting API calls
- Preventing double-clicks

### Live Demonstration

---

# Directives

## Auto Focus

**URL**: https://love1024.github.io/ngx-oneforall/directives/auto-focus
**Import**: `ngx-oneforall/directives/auto-focus`

Automatically focuses an element when rendered, with reactive two-way binding support.

## Features

- **Auto Focus** — Focuses the element immediately on render
- **Two-Way Binding** — Sync focus state with parent via `[(isFocused)]`
- **SSR Safe** — Only runs in the browser via `afterNextRender`

---

## Installation

```typescript
import { AutoFocusDirective } from 'ngx-oneforall/directives/auto-focus';
```

---

## Basic Usage

```html
<!-- Auto focus on render -->
<input autoFocus />

<!-- With two-way binding -->
<input autoFocus [(isFocused)]="focusState" />

<!-- Read-only binding -->
<input autoFocus [isFocused]="shouldFocus" />
```

---

## API Reference

| Input/Output | Type | Default | Description |
|--------------|------|---------|-------------|
| `isFocused` | `ModelSignal<boolean>` | `true` | Two-way bindable focus state |

### Host Events

| Event | Behavior |
|-------|----------|
| `focus` | Sets `isFocused` to `true` |
| `blur` | Sets `isFocused` to `false` |

---

## Programmatic Control

Use two-way binding to control focus from your component:

```typescript
@Component({
  template: `
    <input autoFocus [(isFocused)]="isFocused" />
    <button (click)="focusInput()">Focus Input</button>
  `,
  imports: [AutoFocusDirective]
})
export class MyComponent {
  isFocused = signal(false);

  focusInput() {
    this.isFocused.set(true);
  }
}
```

---

## Live Demo

## Click Outside

**URL**: https://love1024.github.io/ngx-oneforall/directives/click-outside
**Import**: `ngx-oneforall/directives/click-outside`

Detects clicks outside an element, useful for closing dropdowns, modals, and popovers.

## Features

- **Capture Phase** — Detects clicks even when `stopPropagation()` is called
- **Zone Optimized** — Runs outside Angular zone for better performance
- **Toggleable** — Enable/disable via `clickOutsideEnabled` input
- **SSR Safe** — Only activates in the browser

---

## Installation

```typescript
import { ClickOutsideDirective } from 'ngx-oneforall/directives/click-outside';
```

---

## Basic Usage

```html
<div (clickOutside)="onClickedOutside($event)">
  <!-- Dropdown content -->
</div>
```

```typescript
onClickedOutside(event: Event) {
  this.isOpen = false;
}
```

---

## API Reference

| Input/Output | Type | Default | Description |
|--------------|------|---------|-------------|
| `clickOutside` | `OutputEmitterRef<Event>` | — | Emits when a click occurs outside the element |
| `clickOutsideEnabled` | `boolean` | `true` | Enables/disables click detection |

---

## Disabling Detection

Temporarily disable outside click detection:

```html
<div 
  (clickOutside)="close()" 
  [clickOutsideEnabled]="isDropdownOpen">
  <!-- Only detects outside clicks when dropdown is open -->
</div>
```

---

## Common Use Cases

### Dropdown Menu

```typescript
@Component({
  template: `
    <div class="dropdown" (clickOutside)="close()" [clickOutsideEnabled]="isOpen">
      <button (click)="toggle()">Menu</button>
      @if (isOpen) {
        <ul class="menu">...</ul>
      }
    </div>
  `,
  imports: [ClickOutsideDirective]
})
export class DropdownComponent {
  isOpen = false;
  toggle() { this.isOpen = !this.isOpen; }
  close() { this.isOpen = false; }
}
```

---

## Live Demo

## Click Throttle

**URL**: https://love1024.github.io/ngx-oneforall/directives/click-throttle
**Import**: `ngx-oneforall/directives/click-throttle`

Throttles click events to prevent accidental double-clicks and rapid repeated interactions.

## Features

- **Immediate Response** — First click fires instantly (leading edge)
- **Configurable Delay** — Set throttle interval via `throttleTime` input
- **Reactive** — Updates throttle duration when input changes
- **SSR Safe** — Only activates in the browser

---

## Installation

```typescript
import { ClickThrottleDirective } from 'ngx-oneforall/directives/click-throttle';
```

---

## Basic Usage

```html
<!-- Default 1000ms throttle -->
<button (clickThrottle)="submit()">Submit</button>

<!-- Custom 500ms throttle -->
<button [throttleTime]="500" (clickThrottle)="submit()">Submit</button>
```

---

## API Reference

| Input/Output | Type | Default | Description |
|--------------|------|---------|-------------|
| `throttleTime` | `number` | `1000` | Minimum interval (ms) between emissions |
| `clickThrottle` | `OutputEmitterRef<Event>` | — | Emits throttled click events |

---

## How It Works

```
User clicks:    ●──●●●●──────────●●●──────●
                0  200           1500      2800 (ms)

With 1000ms throttle:
Emits:          ●─────────────────●────────●
                0                 1500     2800
```

- First click in each window is emitted immediately
- Subsequent clicks within the throttle period are ignored

---

## Common Use Cases

### Prevent Double Submit

```html
<button [throttleTime]="2000" (clickThrottle)="submitForm()">
  Submit Order
</button>
```

### API Request Protection

```typescript
@Component({
  template: `<button (clickThrottle)="loadMore()">Load More</button>`,
  imports: [ClickThrottleDirective]
})
export class ListComponent {
  loadMore() {
    this.api.fetchNextPage(); // Won't fire more than once per second
  }
}
```

---

## Live Demo

## Draggable

**URL**: https://love1024.github.io/ngx-oneforall/directives/draggable
**Import**: `ngx-oneforall/directives/draggable`

Makes any element draggable with mouse and touch support. Perfect for movable popups, modals, and floating panels.

## Features

- **Mouse & Touch** — Works seamlessly with both input methods
- **Drag Handle** — Separate drag handle from the moved element
- **Boundary Constraints** — Limit dragging to viewport, parent, or custom element
- **Zone Optimized** — Runs outside Angular zone for better performance
- **SSR Safe** — Only activates in the browser

---

## Installation

```typescript
import { DraggableDirective, DraggableDragEvent } from 'ngx-oneforall/directives/draggable';
```

---

## Basic Usage

Make any element draggable:

```html
<div makeDraggable style="position: absolute;">
  Drag me around!
</div>
```

---

## API Reference

### Inputs

| Input | Type | Default | Description |
|-------|------|---------|-------------|
| `makeDraggableEnabled` | `boolean` | `true` | Enables/disables dragging |
| `makeDraggableTarget` | `HTMLElement \| null` | `null` | Element to move (defaults to host element) |
| `makeDraggableBoundary` | `'viewport' \| 'parent' \| HTMLElement \| null` | `null` | Constrains dragging within bounds |
| `makeDraggableThreshold` | `number` | `5` | Minimum distance (px) before drag starts |

### Outputs

| Output | Type | Description |
|--------|------|-------------|
| `dragStart` | `DraggableDragEvent` | Emits when dragging begins |
| `dragMove` | `DraggableDragEvent` | Emits continuously while dragging |
| `dragEnd` | `DraggableDragEvent` | Emits when dragging ends |

### DraggableDragEvent Interface

```typescript
interface DraggableDragEvent {
  x: number;         // Current X position relative to viewport
  y: number;         // Current Y position relative to viewport
  deltaX: number;    // Change in X since last event
  deltaY: number;    // Change in Y since last event
  originalEvent: MouseEvent | TouchEvent;
}
```

---

## Modal with Drag Handle

The most common use case — drag a modal by its header:

```typescript
@Component({
  template: `
    <div class="modal" #modal>
      <div class="modal-header" makeDraggable [makeDraggableTarget]="modal">
        <span>Settings</span>
        <button (click)="close()">×</button>
      </div>
      <div class="modal-body">
        Modal content here...
      </div>
    </div>
  `,
  imports: [DraggableDirective]
})
export class ModalComponent {}
```

---

## Boundary Constraints

### Constrain to Viewport

```html
<div makeDraggable [makeDraggableBoundary]="'viewport'">
  Can't leave the screen!
</div>
```

### Constrain to Parent

```html
<div class="container">
  <div makeDraggable [makeDraggableBoundary]="'parent'">
    Stays within container
  </div>
</div>
```

### Constrain to Custom Element

```html
<div #bounds class="bounds">
  <div makeDraggable [makeDraggableBoundary]="bounds">
    Stays within bounds
  </div>
</div>
```

---

## Event Handling

Track drag position and state:

```typescript
@Component({
  template: `
    <div makeDraggable
         (dragStart)="onDragStart($event)"
         (dragMove)="onDragMove($event)"
         (dragEnd)="onDragEnd($event)">
      Drag me!
    </div>
    <p>Position: ("}}, "}})</p>
    <p>Status: "}}</p>
  `,
  imports: [DraggableDirective]
})
export class TrackingComponent {
  position = { x: 0, y: 0 };
  isDragging = false;

  onDragStart(event: DraggableDragEvent) {
    this.isDragging = true;
  }

  onDragMove(event: DraggableDragEvent) {
    this.position = { x: event.x, y: event.y };
  }

  onDragEnd(event: DraggableDragEvent) {
    this.isDragging = false;
  }
}
```

---

## Multiple Draggable Popups

Each popup maintains its own position independently:

```typescript
@Component({
  template: `
    @for (popup of popups; track popup.id) {
      <div class="popup"
           style="position: absolute;"
           makeDraggable
           [makeDraggableBoundary]="'viewport'">
        <div class="popup-header">"}}</div>
        <div class="popup-content">"}}</div>
      </div>
    }
  `,
  imports: [DraggableDirective]
})
export class MultiPopupComponent {
  popups = [
    { id: 1, title: 'Popup 1', content: 'Content...' },
    { id: 2, title: 'Popup 2', content: 'Content...' },
  ];
}
```

---

## Conditionally Enable

```html
<div makeDraggable
     [makeDraggableEnabled]="isEditMode"
     (dragEnd)="savePosition($event)">
  "}}
</div>
```

---

## Live Demo

## Hover Class

**URL**: https://love1024.github.io/ngx-oneforall/directives/hover-class
**Import**: `ngx-oneforall/directives/hover-class`

Dynamically applies CSS classes on hover with reactive updates and toggle support.

## Features

- **Multiple Classes** — Apply one or more space-separated classes
- **Toggleable** — Enable/disable via `hoverClassEnabled` input
- **Auto Cleanup** — Classes removed automatically when disabled
- **SSR Safe** — Only activates in the browser

---

## Installation

```typescript
import { HoverClassDirective } from 'ngx-oneforall/directives/hover-class';
```

---

## Basic Usage

```html
<!-- Single class -->
<button hoverClass="highlight">Hover me</button>

<!-- Multiple classes -->
<div hoverClass="shadow-lg border-primary">Hover card</div>

<!-- Conditional enable -->
<span hoverClass="underline" [hoverClassEnabled]="isActive()">Link</span>
```

---

## API Reference

| Input | Type | Default | Description |
|-------|------|---------|-------------|
| `hoverClass` | `string` | *required* | Space-separated CSS classes to apply on hover |
| `hoverClassEnabled` | `boolean` | `true` | Enables/disables the hover effect |

---

## Behavior

| State | Action |
|-------|--------|
| Mouse enter (enabled) | Adds all specified classes |
| Mouse leave (enabled) | Removes all specified classes |
| `hoverClassEnabled=false` | Immediately removes any applied classes |
| `hoverClass` changes | Updates classes to toggle on next hover |

---

## Common Use Cases

### Button Hover Effect

```html
<button hoverClass="bg-primary text-white scale-105">
  Submit
</button>
```

### Card Hover Shadow

```typescript
@Component({
  template: `
    <div class="card" hoverClass="shadow-xl transform-up">
      
    </div>
  `,
  imports: [HoverClassDirective]
})
export class CardComponent {}
```

---

## Live Demo

## Infinite Scroll

**URL**: https://love1024.github.io/ngx-oneforall/directives/infinite-scroll
**Import**: `ngx-oneforall/directives/infinite-scroll`

Implements infinite scroll behavior using IntersectionObserver for efficient detection.

## Features

- **IntersectionObserver** — No scroll event listeners, better performance
- **Reactive** — Automatically reinitializes when inputs change
- **Flexible Container** — Works with window, custom container, or auto-detects parent
- **Configurable Threshold** — Control trigger distance via `bottomMargin`
- **SSR Safe** — Only activates in the browser

---

## Installation

```typescript
import { InfiniteScrollDirective } from 'ngx-oneforall/directives/infinite-scroll';
```

---

## Basic Usage

```html
<!-- Window scrolling (default) -->
<div infiniteScroll (scrolled)="loadMore()">
  @for (item of items(); track item.id) {
    <div></div>
  }
</div>
```

---

## API Reference

| Input | Type | Default | Description |
|-------|------|---------|-------------|
| `bottomMargin` | `number` | `20` | Distance (%) from bottom to trigger |
| `useWindow` | `boolean` | `true` | Use window vs container scroll |
| `scrollContainer` | `string` | `null` | CSS selector for custom container |
| `disabled` | `boolean` | `false` | Disable scroll detection |
| `checkOnInit` | `boolean` | `true` | Emit on initial render if visible |
| `initDelay` | `number` | `1000` | Delay (ms) to ignore initial intersections |

| Output | Type | Description |
|--------|------|-------------|
| `scrolled` | `void` | Emits when scroll reaches threshold |

---

## Container Scrolling

For a specific scrollable container:

```html
<div 
  class="scroll-container" 
  infiniteScroll 
  [useWindow]="false"
  [scrollContainer]="'.scroll-container'"
  (scrolled)="loadMore()">
  <!-- Items -->
</div>
```

---

## Common Use Cases

### Paginated List

```typescript
@Component({
  template: `
    <div infiniteScroll (scrolled)="loadNextPage()" [disabled]="loading()">
      @for (item of items(); track item.id) {
        <app-item [data]="item" />
      }
      @if (loading()) {
        <div class="spinner">Loading...</div>
      }
    </div>
  `,
  imports: [InfiniteScrollDirective]
})
export class ListComponent {
  items = signal<Item[]>([]);
  loading = signal(false);
  page = 0;

  loadNextPage() {
    this.loading.set(true);
    this.api.getItems(++this.page).subscribe(newItems => {
      this.items.update(items => [...items, ...newItems]);
      this.loading.set(false);
    });
  }
}
```

---

## Live Demo

## Numbers Only

**URL**: https://love1024.github.io/ngx-oneforall/directives/numbers-only
**Import**: `ngx-oneforall/directives/numbers-only`

Restricts user input to valid numeric values with configurable decimal places and negative number support.

## Features

- **Input Validation** — Blocks non-numeric characters on input, paste, and cut
- **Decimal Control** — Configure allowed decimal places
- **Negative Support** — Optionally allow negative numbers
- **Custom Separator** — Use any decimal separator (`.`, `,`, etc.)
- **Forms Compatible** — Works with both native inputs and Angular forms

---

## Installation

```typescript
import { NumbersOnlyDirective } from 'ngx-oneforall/directives/numbers-only';
```

---

## API Reference

| Input | Type | Default | Description |
|-------|------|---------|-------------|
| `decimals` | `number` | `0` | Decimal places allowed (0 = integers only) |
| `negative` | `boolean` | `false` | Allow negative numbers |
| `separator` | `string` | `'.'` | Decimal separator character |

---

## Basic Usage

```html
<!-- Integers only (default) -->
<input numbersOnly />

<!-- Allow 2 decimal places -->
<input numbersOnly [decimals]="2" />

<!-- Allow negative values -->
<input numbersOnly [negative]="true" />

<!-- Custom separator (comma) -->
<input numbersOnly [decimals]="2" [separator]="','" />
```

---

## Common Use Cases

### Currency Input

```html
<input 
  numbersOnly 
  [decimals]="2" 
  placeholder="$0.00" />
```

### Quantity Field

```html
<input 
  numbersOnly 
  [negative]="true" 
  placeholder="Enter quantity" />
```

### Reactive Forms

```typescript
@Component({
  template: `<input numbersOnly [decimals]="2" [formControl]="price" />`,
  imports: [NumbersOnlyDirective, ReactiveFormsModule]
})
export class PriceFormComponent {
  price = new FormControl('');
}
```

---

## Live Demo

## Press Enter

**URL**: https://love1024.github.io/ngx-oneforall/directives/press-enter
**Import**: `ngx-oneforall/directives/press-enter`

Emits an event when the Enter key is pressed on any element.

## Features

- **Enter Key Detection** — Listens for `keydown.enter` event
- **Prevent Default** — Optionally prevents form submission
- **Simple API** — Just add the directive and listen

---

## Installation

```typescript
import { PressEnterDirective } from 'ngx-oneforall/directives/press-enter';
```

---

## API Reference

| Input | Type | Default | Description |
|-------|------|---------|-------------|
| `preventDefault` | `boolean` | `true` | Prevent default Enter behavior |

| Output | Type | Description |
|--------|------|-------------|
| `pressEnter` | `void` | Emits when Enter is pressed |

---

## Basic Usage

```html
<input (pressEnter)="onSubmit()" placeholder="Press Enter" />
```

```typescript
onSubmit() {
  console.log('Enter pressed!');
}
```

---

## Common Use Cases

### Search Input

```html
<input 
  [(ngModel)]="searchQuery"
  (pressEnter)="search()"
  placeholder="Search..." />
```

### Chat Message

```html
<input 
  [(ngModel)]="message"
  (pressEnter)="sendMessage()"
  placeholder="Type a message..." />
```

### Allow Default Behavior

```html
<!-- Don't prevent form submission -->
<input 
  (pressEnter)="onEnter()" 
  [preventDefault]="false" />
```

---

## Live Demo

## Repeat

**URL**: https://love1024.github.io/ngx-oneforall/directives/repeat
**Import**: `ngx-oneforall/directives/repeat`

A structural directive that repeats a template a specified number of times.

## Features

- **Reactive** — Re-renders when count changes
- **Rich Context** — Exposes index, first, last, even, odd
- **Safe** — Handles negative numbers gracefully

---

## Installation

```typescript
import { RepeatDirective } from 'ngx-oneforall/directives/repeat';
```

---

## API Reference

| Input | Type | Default | Description |
|-------|------|---------|-------------|
| `repeat` | `number` | `1` | Number of times to repeat |

### Context Variables

| Variable | Type | Description |
|----------|------|-------------|
| `$implicit` | `number` | Current index (0-based) |
| `index` | `number` | Same as `$implicit` |
| `first` | `boolean` | True if first iteration |
| `last` | `boolean` | True if last iteration |
| `even` | `boolean` | True if index is even |
| `odd` | `boolean` | True if index is odd |

---

## Basic Usage

```html
<div *repeat="5; let i">
  Item 
</div>
```

---

## Using Context Variables

```html
<ng-container *repeat="3; let i; let isFirst = first; let isLast = last; let isEven = even">
  <span>Index: </span>
  @if (isFirst) { <span>← First</span> }
  @if (isLast) { <span>← Last</span> }
  @if (isEven) { <span>← Even</span> }
</ng-container>
```

---

## Common Use Cases

### Star Rating

```html
<span *repeat="5; let i">
  ★
</span>
```

### Skeleton Loaders

```html
<div *repeat="3" class="skeleton-row"></div>
```

### Pagination Dots

```html
<span *repeat="pageCount; let i" 
      [class.active]="i === currentPage"
      (click)="goToPage(i)">
  ●
</span>
```

---

## Live Demo

## Resized

**URL**: https://love1024.github.io/ngx-oneforall/directives/resized
**Import**: `ngx-oneforall/directives/resized`

Detects element resize events using ResizeObserver and emits current/previous dimensions.

## Features

- **ResizeObserver API** — Efficient native resize detection
- **Previous Dimensions** — Tracks both current and previous size
- **Debounce Support** — Optional debouncing for rapid resize events
- **Zone Optimized** — Runs outside Angular zone for performance
- **SSR Safe** — Only activates in the browser

---

## Installation

```typescript
import { ResizedDirective, ResizedEvent } from 'ngx-oneforall/directives/resized';
```

---

## API Reference

| Input | Type | Default | Description |
|-------|------|---------|-------------|
| `debounceTime` | `number` | `0` | Debounce time in ms (0 = no debounce) |

| Output | Type | Description |
|--------|------|-------------|
| `resized` | `ResizedEvent` | Emits on size change |

### ResizedEvent

```typescript
interface ResizedEvent {
  current: DOMRectReadOnly;   // Current dimensions
  previous: DOMRectReadOnly | null;  // Previous dimensions
}
```

---

## Basic Usage

```html
<div (resized)="onResize($event)">
  Resizable content
</div>
```

```typescript
onResize(event: ResizedEvent) {
  console.log('Width:', event.current.width);
  console.log('Height:', event.current.height);
}
```

---

## With Debouncing

```html
<div (resized)="onResize($event)" [debounceTime]="100">
  Resizable content
</div>
```

---

## Common Use Cases

### Responsive Component

```typescript
@Component({
  template: `
    <div (resized)="onResize($event)">
      @if (isCompact()) {
        <span>Compact</span>
      } @else {
        <span>Full</span>
      }
    </div>
  `,
  imports: [ResizedDirective]
})
export class ResponsiveComponent {
  isCompact = signal(false);

  onResize(event: ResizedEvent) {
    this.isCompact.set(event.current.width < 400);
  }
}
```

### Size Display

```html
<div (resized)="size.set($event.current)" style="resize: both; overflow: auto;">
  Width: "}} x Height: "}}
</div>
```

---

## Live Demo

## Shortcut

**URL**: https://love1024.github.io/ngx-oneforall/directives/shortcut
**Import**: `ngx-oneforall/directives/shortcut`

Binds keyboard shortcuts to trigger actions with support for modifiers and global/scoped listening.

## Features

- **Multiple Shortcuts** — Comma-separated patterns (e.g., `'ctrl.s, meta.s'`)
- **Modifier Support** — `ctrl`, `shift`, `alt`, `meta` (cmd)
- **Global/Scoped** — Listen on window or element-only
- **Layout Independent** — Uses physical key codes for cross-keyboard support
- **Performance Optimized** — Cached shortcut parsing with computed signals

---

## Installation

```typescript
import { ShortcutDirective } from 'ngx-oneforall/directives/shortcut';
```

---

## API Reference

| Input | Type | Default | Description |
|-------|------|---------|-------------|
| `shortcut` | `string` | **Required** | Shortcut pattern(s) |
| `isGlobal` | `boolean` | `false` | Listen globally on window |

| Output | Type | Description |
|--------|------|-------------|
| `action` | `void` | Emits when shortcut is triggered |

### Shortcut Format

```
modifier.modifier.key
```

**Modifiers:** `ctrl`, `shift`, `alt`, `meta`, `cmd`

**Examples:**
- `ctrl.s` — Ctrl+S
- `meta.s` — Cmd+S (Mac)
- `ctrl.shift.s` — Ctrl+Shift+S
- `ctrl.s, meta.s` — Ctrl+S or Cmd+S

---

## Basic Usage

```html
<!-- Element scoped (requires focus) -->
<input [shortcut]="'ctrl.s'" (action)="save()" />

<!-- Global (works anywhere) -->
<div [shortcut]="'ctrl.k'" [isGlobal]="true" (action)="openSearch()"></div>
```

---

## Common Use Cases

### Save Shortcut (Cross-Platform)

```html
<div [shortcut]="'ctrl.s, meta.s'" [isGlobal]="true" (action)="save()">
  Press Ctrl+S or Cmd+S to save
</div>
```

### Command Palette

```typescript
@Component({
  template: `
    <div [shortcut]="'ctrl.k, meta.k'" [isGlobal]="true" (action)="openPalette()">
      @if (paletteOpen()) {
        <command-palette />
      }
    </div>
  `,
  imports: [ShortcutDirective]
})
export class AppComponent {
  paletteOpen = signal(false);
  
  openPalette() {
    this.paletteOpen.set(true);
  }
}
```

---

## Live Demo

## Typed Template

**URL**: https://love1024.github.io/ngx-oneforall/directives/typed-template
**Import**: `ngx-oneforall/directives/typed-template`

The `TypedTemplateDirective` provides a way to strictly type the context of your `ng-template` definitions. By default, Angular templates are weakly typed (`any` or `Object`), which can lead to runtime errors when accessing properties that don't exist. This directive bridges that gap, leveraging TypeScript's power directly within your templates.

> **Note**
> This directive is purely for compile-time type checking. It does not affect runtime behavior or inject data into the template. The actual data context must still be provided via `[ngTemplateOutletContext]` or similar mechanisms.

---

### Usage

#### 1. Import the Directive

Import `TypedTemplateDirective` into your component or module.

```typescript
import { TypedTemplateDirective } from 'ngx-oneforall/directives/typed-template';

@Component({
  imports: [TypedTemplateDirective],
  // ...
})
export class MyComponent {}
```

#### 2. Apply to Template

To type a template, start by defining the interface for your context.

```typescript
interface UserContext {
  $implicit: string; // The type for let-name
  age: number;       // The type for let-age="age"
}
```

Then, use a helper property to pass this type to the directive. This property is used purely for type inference.

```typescript
protected get userContextType() {
  return {} as UserContext;
}
```

Finally, bind `[typedTemplate]` to your type helper on the `ng-template`.

```html
<ng-template [typedTemplate]="userContextType" let-name let-age="age">
  <!-- 'name' is strictly typed as string -->
  <!-- 'age' is strictly typed as number -->
  <div>Name: </div>
  <div>Age: </div>
</ng-template>
```

---

### Why use it?

1. **Catch Errors Early**: Typo in a property name? Accessing a missing nested field? TypeScript will catch these errors at build time, preventing runtime crashes.
2. **Better IDE Support**: Enjoy full autocomplete and refactoring capabilities for variables inside your templates, just like in your TypeScript files.
3. **Clear Contracts**: It explicitly documents the data shape expected by the template, making the code easier to understand and maintain for your team.

---

### Live Demo

## Visibility Change

**URL**: https://love1024.github.io/ngx-oneforall/directives/visibility-change
**Import**: `ngx-oneforall/directives/visibility-change`

Detects when an element enters or leaves the viewport using IntersectionObserver.

## Features

- **Visibility Detection** — Emits when element becomes visible/hidden
- **Configurable Threshold** — Control visibility percentage to trigger
- **Custom Root** — Observe within viewport or custom container
- **Root Margin** — Adjust intersection area with margin
- **Zone Optimized** — Observer runs outside Angular zone
- **SSR Safe** — Only activates in the browser

---

## Installation

```typescript
import { VisibilityChangeDirective, VisibilityChange } from 'ngx-oneforall/directives/visibility-change';
```

---

## API Reference

| Input | Type | Default | Description |
|-------|------|---------|-------------|
| `threshold` | `number` | `1.0` | Visibility % to trigger (0-1) |
| `root` | `HTMLElement \| null` | `null` | Custom scroll container |
| `rootMargin` | `string` | `'0px'` | Margin around root |

| Output | Type | Description |
|--------|------|-------------|
| `visibilityChange` | `VisibilityChange` | Emits on visibility change |

### VisibilityChange Type

```typescript
type VisibilityChange = 
  | { isVisible: true; target: HTMLElement }
  | { isVisible: false; target: HTMLElement | undefined };
```

---

## Basic Usage

```html
<div (visibilityChange)="onVisible($event)">
  Watch me!
</div>
```

```typescript
onVisible(event: VisibilityChange) {
  if (event.isVisible) {
    console.log('Element is visible');
  }
}
```

---

## Common Use Cases

### Lazy Load Content

```typescript
@Component({
  template: `
    <div (visibilityChange)="onVisible($event)" [threshold]="0.1">
      @if (loaded()) {
        <heavy-component />
      } @else {
        <div class="placeholder">Loading...</div>
      }
    </div>
  `,
  imports: [VisibilityChangeDirective]
})
export class LazyComponent {
  loaded = signal(false);

  onVisible(event: VisibilityChange) {
    if (event.isVisible && !this.loaded()) {
      this.loaded.set(true);
    }
  }
}
```

### Animate on Scroll

```html
<div 
  (visibilityChange)="visible.set($event.isVisible)"
  [threshold]="0.5"
  [class.animate-in]="visible()">
  Animated content
</div>
```

---

## Live Demo

---

# Guards

## Param Guard

**URL**: https://love1024.github.io/ngx-oneforall/guards/param
**Import**: `ngx-oneforall/guards/param`

`paramGuard` is a functional guard that validates route parameters (path variables) before allowing activation of a route. It works similarly to `queryParamGuard` but for route parameters.

## Usage

To use `paramGuard`, provide it in your route configuration using `canActivate`. It is particularly useful for validating required parameters in routes like `/item/:id`.

```typescript
import { paramGuard } from 'ngx-oneforall/guards/param';

const routes: Routes = [
  {
    path: 'users/:id',
    component: UserComponent,
    canActivate: [
      paramGuard({
        required: ['id'],
        // predicate: (params) => params['id'].startsWith('usr_'),
        redirectTo: '/not-found',
      }),
    ],
  },
];
```

## Configuration

The `paramGuard` factory takes a `ParamGuardConfig` object:

| Property     | Type                                       | Description                                                                 |
| ------------ | ------------------------------------------ | --------------------------------------------------------------------------- |
| `required`   | `string[]`                                 | List of parameter keys that must be present and non-empty.                  |
| `predicate`  | `(params: Record<string, string>) => boolean` | A custom function to validate parameters.                                   |
| `redirectTo` | `string`                                   | Optional URL to redirect to if validation fails (uses `RedirectCommand`). |

## Demo

## Query Param Guard

**URL**: https://love1024.github.io/ngx-oneforall/guards/query-param
**Import**: `ngx-oneforall/guards/query-param`

`queryParamGuard` is a functional guard that validates query parameters before allowing activation of a route. It can check for required parameters and apply custom logic via a predicate function.

## Usage

To use `queryParamGuard`, provide it in your route configuration using `canActivate`:

```typescript
import { queryParamGuard } from 'ngx-oneforall/guards/query-param';

const routes: Routes = [
  {
    path: 'protected',
    component: ProtectedComponent,
    canActivate: [
      queryParamGuard({
        required: ['id'],
        predicate: (params) => params['type'] === 'admin',
        redirectTo: '/unauthorized',
      }),
    ],
  },
];
```

## Configuration

The `queryParamGuard` factory takes a `QueryParamGuardConfig` object:

| Property     | Type                                       | Description                                                                 |
| ------------ | ------------------------------------------ | --------------------------------------------------------------------------- |
| `required`   | `string[]`                                 | List of query parameter keys that must be present and non-empty.            |
| `predicate`  | `(params: Params) => boolean` | A custom function to validate query parameters.                             |
| `redirectTo` | `string`                                   | Optional URL to redirect to if validation fails (uses `RedirectCommand`). |

## Demo



> **Note**
> If `redirectTo` is not provided, the guard will simply return `false` on failure.

## Unsaved Changes Guard

**URL**: https://love1024.github.io/ngx-oneforall/guards/unsaved-changes
**Import**: `ngx-oneforall/guards/unsaved-changes`

Unsaved changes guards are essential for protecting users from accidentally losing their work when navigating away from a page with unsaved modifications. This guard leverages the native `window.confirm` dialog to prompt the user for confirmation.

#### How to Use

1. **Import the Guard**
    Import `unsavedChangesGuard` and the `HasUnsavedChanges` interface:
    ```typescript
    import { HasUnsavedChanges, unsavedChangesGuard } from 'ngx-oneforall/guards/unsaved-changes';
    ```

2. **Register the Guard**
    Add the guard to your route configuration using `canDeactivate`:
    ```typescript {4}
    {
      path: 'form',
      canDeactivate: [
         unsavedChangesGuard()
      ]
    }
    ```

3. **Implement the Interface**
    Implement `HasUnsavedChanges` in your component:
    ```typescript
    export class UnsavedChangesDemoComponent implements HasUnsavedChanges {
      // ...
      hasUnsavedChanges() {
         return this.form.dirty;
      }
    }
    ```

4. **Async Checks (Optional)**
    The `hasUnsavedChanges` method can return a `boolean`, `Promise<boolean>`, or `Observable<boolean>`.
    
    ```typescript
    hasUnsavedChanges(): Observable<boolean> {
       return this.apiClient.checkDraftStatus().pipe(
         map(status => status.hasChanges)
       );
    }
    ```

#### Use Cases
- Preventing navigation away from a form with unsaved data.
- Alerting users before closing a tab or browser window if changes haven't been saved.
- Guarding against accidental loss of progress in multi-step wizards or editors.

#### Live Demo

> **Note**
> This demo manually triggers the guard check to show the confirmation dialog. In a real routing scenario, this would happen automatically before navigation.




#### Customizing the Confirmation Message
You can customize the message displayed in the confirmation dialog by passing a string to the factory function.

```typescript {4}
  {
    path: 'form',
    canDeactivate: [
      unsavedChangesGuard('You have unsaved work! Are you sure you want to leave?')
    ]
  }
```

---

# Interceptors

## Base URL Interceptor

**URL**: https://love1024.github.io/ngx-oneforall/interceptors/base-url
**Import**: `ngx-oneforall/interceptors/base-url`

The `withBaseUrlInterceptor` is an Angular HTTP interceptor that automatically prepends a base URL to all relative HTTP requests. It eliminates repetitive URL construction across your application.

## Features

- **Single configuration point** — Define your API base URL once
- **Relative paths** — Use `/users` instead of `https://api.example.com/users`
- **Dynamic URLs** — Support for functions that resolve URLs at runtime
- **Path-specific overrides** — Route different paths to different base URLs
- **Per-request control** — Disable or override via `HttpContext`
- **Smart slash handling** — Automatically normalizes trailing/leading slashes

## Installation

```typescript
import { withBaseUrlInterceptor } from 'ngx-oneforall/interceptors/base-url';
```

## Quick Start

### Standalone Applications

```typescript
import { provideHttpClient, withInterceptors } from '@angular/common/http';
import { withBaseUrlInterceptor } from 'ngx-oneforall/interceptors/base-url';

export const appConfig: ApplicationConfig = {
  providers: [
    provideHttpClient(
      withInterceptors([
        withBaseUrlInterceptor({ baseUrl: 'https://api.example.com' })
      ])
    ),
  ],
};
```

### NgModule Applications

```typescript
import { HTTP_INTERCEPTORS } from '@angular/common/http';
import { withBaseUrlInterceptor } from 'ngx-oneforall/interceptors/base-url';

@NgModule({
  providers: [
    { 
      provide: HTTP_INTERCEPTORS, 
      useValue: withBaseUrlInterceptor({ baseUrl: 'https://api.example.com' }), 
      multi: true 
    }
  ]
})
export class AppModule {}
```

### Making Requests

```typescript
// Before (without interceptor)
this.http.get('https://api.example.com/users');

// After (with interceptor)
this.http.get('/users'); // → https://api.example.com/users
```

## Configuration

### BaseUrlConfig

| Property | Type | Required | Description |
|----------|------|----------|-------------|
| `baseUrl` | `string \| (() => string)` | **Yes** | Default base URL for all relative requests |
| `overrides` | `BaseUrlOverrides[]` | No | Path-specific base URL overrides |

### BaseUrlOverrides

| Property | Type | Description |
|----------|------|-------------|
| `startWith` | `string` | Path prefix to match (e.g., `'auth'`, `'api/v2'`) |
| `url` | `string \| (() => string)` | Base URL to use when prefix matches |

> **Warning**
> The `baseUrl` option is required. The interceptor throws an error if not provided.

## Behavior

### Processing Order

The interceptor processes requests in the following order:

1. **Check context** — If disabled via `HttpContext`, pass through unchanged
2. **Check absolute URL** — If the request URL starts with `http://` or `https://`, pass through unchanged
3. **Resolve base URL** — Use context override, matching path override, or default `baseUrl`
4. **Join URLs** — Combine base URL and request path with proper slash handling

### Smart Slash Handling

The interceptor automatically normalizes slashes between the base URL and path:

```typescript
// All produce: https://api.example.com/users

withBaseUrlInterceptor({ baseUrl: 'https://api.example.com/' })
this.http.get('/users')   // trailing + leading slash

withBaseUrlInterceptor({ baseUrl: 'https://api.example.com' })
this.http.get('users')    // no slashes

withBaseUrlInterceptor({ baseUrl: 'https://api.example.com/' })
this.http.get('users')    // trailing slash only
```

### Absolute URLs Pass Through

Requests with absolute URLs are never modified:

```typescript
this.http.get('/users');                          // → https://api.example.com/users
this.http.get('https://other-api.com/data');      // → https://other-api.com/data (unchanged)
```

## Context API

Control the interceptor on a per-request basis using `useBaseUrl`:

```typescript
import { useBaseUrl } from 'ngx-oneforall/interceptors/base-url';
```

### Disable for a Request

```typescript
this.http.get('https://external-api.com/data', {
  context: useBaseUrl({ enabled: false })
});
```

### Override Base URL

```typescript
this.http.get('/admin/settings', {
  context: useBaseUrl({ baseUrl: 'https://admin-api.example.com' })
});
```

### Context Options

| Option | Type | Description |
|--------|------|-------------|
| `enabled` | `boolean` | Set `false` to skip base URL prepending |
| `baseUrl` | `string \| (() => string)` | Override the configured base URL |
| `context` | `HttpContext` | Extend an existing `HttpContext` |

## Examples

### Environment-Based Configuration

```typescript
// environments/environment.ts
export const environment = {
  production: false,
  apiUrl: 'http://localhost:3000'
};

// environments/environment.prod.ts
export const environment = {
  production: true,
  apiUrl: 'https://api.production.com'
};

// app.config.ts
import { environment } from './environments/environment';

export const appConfig: ApplicationConfig = {
  providers: [
    provideHttpClient(
      withInterceptors([
        withBaseUrlInterceptor({ baseUrl: environment.apiUrl })
      ])
    ),
  ],
};
```

### Dynamic URL with Dependency Injection

Use a function to resolve the base URL dynamically in the injection context:

```typescript
import { inject, InjectionToken } from '@angular/core';

export const API_URL = new InjectionToken<string>('API_URL');

export const appConfig: ApplicationConfig = {
  providers: [
    { provide: API_URL, useValue: 'https://api.example.com' },
    provideHttpClient(
      withInterceptors([
        withBaseUrlInterceptor({
          baseUrl: () => inject(API_URL)
        })
      ])
    ),
  ],
};
```

### Path-Specific Overrides

Route specific path prefixes to different base URLs:

```typescript
withBaseUrlInterceptor({
  baseUrl: 'https://api.example.com',
  overrides: [
    { startWith: 'auth', url: 'https://auth.example.com' },
    { startWith: 'api/v2', url: 'https://api-v2.example.com' },
    { startWith: 'assets', url: () => inject(ASSETS_URL) }
  ]
})
```

**Matching behavior:**
- `/auth/login` → `https://auth.example.com/auth/login`
- `/api/v2/users` → `https://api-v2.example.com/api/v2/users`
- `/users` → `https://api.example.com/users`

> **Note**
> Overrides are matched in array order. The first matching prefix wins.

### Mixed API Endpoints

```typescript
// Default: all requests use https://api.example.com
export const appConfig: ApplicationConfig = {
  providers: [
    provideHttpClient(
      withInterceptors([
        withBaseUrlInterceptor({ baseUrl: 'https://api.example.com' })
      ])
    ),
  ],
};

// Override for specific requests
@Injectable()
class AnalyticsService {
  constructor(private http: HttpClient) {}

  trackEvent(event: string) {
    return this.http.post('/events', { event }, {
      context: useBaseUrl({ baseUrl: 'https://analytics.example.com' })
    });
  }
}
```

## Demo

Explore a live demonstration of the base URL interceptor:

## Cache Interceptor

**URL**: https://love1024.github.io/ngx-oneforall/interceptors/cache
**Import**: `ngx-oneforall/interceptors/cache`

The `withCacheInterceptor` caches HTTP responses to improve performance.

## Features

- **Two strategies** — Auto (all GETs) or manual (per-request)
- **Multiple storage** — Memory, localStorage, or sessionStorage
- **TTL support** — Configurable time-to-live
- **Version invalidation** — Bust cache on version change
- **SSR-safe** — Skips caching on server

## Installation

```typescript
import { withCacheInterceptor } from 'ngx-oneforall/interceptors/cache';
```

## Quick Start

```typescript
provideHttpClient(
  withInterceptors([
    withCacheInterceptor({ strategy: 'auto' })
  ])
);
```

## Configuration

| Property | Type | Default | Description |
|----------|------|---------|-------------|
| `strategy` | `'auto' \| 'manual'` | `'manual'` | Auto caches all GETs, manual requires context |
| `storage` | `'memory' \| 'local' \| 'session'` | `'memory'` | Default storage backend |
| `ttl` | `number` | `3600000` | Default TTL in milliseconds (1 hour) |
| `storagePrefix` | `string` | — | Key prefix for storage |
| `version` | `string` | — | Cache version for invalidation |
| `cacheBust` | `(req) => boolean \| void` | — | Function for cache invalidation. Return `true` to clear cache. |

## Strategies

### Auto Strategy

Caches all GET requests with JSON response type automatically:

```typescript
withCacheInterceptor({ strategy: 'auto' })
```

### Manual Strategy (Default)

Only caches requests with explicit context:

```typescript
import { useCache } from 'ngx-oneforall/interceptors/cache';

this.http.get('/api/data', {
  context: useCache()
});
```

## Cache Invalidation (Cache Bust)

You can provide a `cacheBust` function to implement custom cache invalidation logic. This function runs in the injection context, so you can use `inject()`. Return `true` to automatically clear the entire cache.

```typescript
withCacheInterceptor({
  cacheBust: (req) => {
    // Automatically clear cache on logout
    if (req.url.includes('/logout')) {
      return true;
    }
  }
})
```

## Per-Request Options

```typescript
this.http.get('/api/data', {
  context: useCache({
    enabled: true,
    key: 'custom-key',
    ttl: 60000,
    storage: 'session'
  })
});
```

| Option | Type | Description |
|--------|------|-------------|
| `enabled` | `boolean` | Enable/disable caching for this request |
| `key` | `string \| (req) => string` | Custom cache key |
| `ttl` | `number` | TTL override for this request |
| `storage` | `'memory' \| 'local' \| 'session'` | Storage override |

## Dynamic Cache Keys

```typescript
this.http.get('/api/users', {
  context: useCache({
    key: req => `users-${req.params.get('page')}`
  })
});
```

## Demo

## Correlation ID Interceptor

**URL**: https://love1024.github.io/ngx-oneforall/interceptors/correlation-id
**Import**: `ngx-oneforall/interceptors/correlation-id`

The `withCorrelationIdInterceptor` is an Angular HTTP interceptor that automatically adds a unique correlation ID header to each HTTP request. It enables request tracking, debugging, and distributed tracing across services.

## Features

- **Automatic ID generation** — Unique ID added to every request
- **Distributed tracing** — Track requests across microservices
- **Custom header name** — Use your own header (default: `X-Correlation-Id`)
- **Custom ID generator** — Provide your own ID generation logic
- **Per-request control** — Disable or override via `HttpContext`
- **SSR-compatible** — Works on both server and browser

## Installation

```typescript
import { withCorrelationIdInterceptor } from 'ngx-oneforall/interceptors/correlation-id';
```

## Quick Start

### Standalone Applications

```typescript
import { provideHttpClient, withInterceptors } from '@angular/common/http';
import { withCorrelationIdInterceptor } from 'ngx-oneforall/interceptors/correlation-id';

export const appConfig: ApplicationConfig = {
  providers: [
    provideHttpClient(
      withInterceptors([withCorrelationIdInterceptor()])
    ),
  ],
};
```

### NgModule Applications

```typescript
import { HTTP_INTERCEPTORS } from '@angular/common/http';
import { withCorrelationIdInterceptor } from 'ngx-oneforall/interceptors/correlation-id';

@NgModule({
  providers: [
    { 
      provide: HTTP_INTERCEPTORS, 
      useValue: withCorrelationIdInterceptor(), 
      multi: true 
    }
  ]
})
export class AppModule {}
```

### Result

Every request automatically includes a correlation ID:

```
GET /api/users
X-Correlation-Id: 550e8400-e29b-41d4-a716-446655440000
```

## Configuration

### CorrelationIdConfig

| Property | Type | Default | Description |
|----------|------|---------|-------------|
| `header` | `string` | `'X-Correlation-Id'` | Header name for the correlation ID |
| `idGenerator` | `() => string` | `crypto.randomUUID()` | Function to generate unique IDs |

### Custom Header Name

```typescript
withCorrelationIdInterceptor({
  header: 'X-Request-Id'
})
```

### Custom ID Generator

```typescript
withCorrelationIdInterceptor({
  idGenerator: () => `req-${Date.now()}-${Math.random().toString(16).slice(2)}`
})
```

### Default ID Generator

Uses `crypto.randomUUID()` when available, with a fallback for older browsers:

```typescript
crypto.randomUUID?.() ?? `${Date.now()}-${Math.random().toString(16).slice(2)}`
```

## Behavior

### Processing Order

The interceptor processes requests in the following order:

1. **Check context** — If disabled via `HttpContext`, pass through
2. **Check existing header** — If header already present, don't override
3. **Add correlation ID** — Use context ID, or generate a new one

### SSR Support

The interceptor is fully compatible with server-side rendering (SSR) and will add correlation IDs to requests made on the server.

### Existing Headers Preserved

If a request already has the correlation ID header, it won't be overridden:

```typescript
// Manual header takes precedence
this.http.get('/api/data', {
  headers: { 'X-Correlation-Id': 'my-custom-id' }
});
```

## Context API

Control the interceptor on a per-request basis using `useCorrelationId`:

```typescript
import { useCorrelationId } from 'ngx-oneforall/interceptors/correlation-id';
```

### Disable for a Request

```typescript
this.http.get('/api/public', {
  context: useCorrelationId({ enabled: false })
});
```

### Use a Specific ID

```typescript
this.http.post('/api/checkout', cart, {
  context: useCorrelationId({ id: 'checkout-flow-12345' })
});
```

### Context Options

| Option | Type | Description |
|--------|------|-------------|
| `enabled` | `boolean` | Set `false` to skip adding correlation ID |
| `id` | `string` | Use a specific ID instead of generating one |
| `context` | `HttpContext` | Extend an existing `HttpContext` |

## Examples

### Distributed Tracing

Track requests across your entire system:

```typescript
// Frontend sends request
this.http.get('/api/orders/123').subscribe();
// Header: X-Correlation-Id: 550e8400-e29b-41d4-a716-446655440000

// Backend logs with the same ID
// [550e8400-...] API Gateway: Received request
// [550e8400-...] Order Service: Fetching order 123
// [550e8400-...] Database: Query executed in 15ms
```

### User-Scoped IDs

Include user context in correlation IDs:

```typescript
withCorrelationIdInterceptor({
  idGenerator: () => {
    const userId = inject(AuthService).userId();
    return `${userId}-${crypto.randomUUID()}`;
  }
})
```

### Action Tracking

Track specific user actions:

```typescript
const checkoutId = `checkout-${crypto.randomUUID()}`;

// All checkout-related requests share the same correlation ID
this.http.post('/api/validate-cart', cart, {
  context: useCorrelationId({ id: checkoutId })
});

this.http.post('/api/process-payment', payment, {
  context: useCorrelationId({ id: checkoutId })
});

this.http.post('/api/create-order', order, {
  context: useCorrelationId({ id: checkoutId })
});
```

### Multiple Header Formats

Different backend services may expect different headers:

```typescript
// For AWS X-Ray
withCorrelationIdInterceptor({ header: 'X-Amzn-Trace-Id' });

// For Zipkin
withCorrelationIdInterceptor({ header: 'X-B3-TraceId' });

// For custom systems
withCorrelationIdInterceptor({ header: 'X-Request-Id' });
```

## Demo

Explore a live demonstration of the correlation ID interceptor:

## Encryption Interceptor

**URL**: https://love1024.github.io/ngx-oneforall/interceptors/encryption
**Import**: `ngx-oneforall/interceptors/encryption`

The `withEncryptionInterceptor` encrypts request bodies and decrypts response bodies using a configurable adapter.

## Features

- **Pluggable adapters** — Use any encryption library (CryptoJS, Web Crypto, etc.)
- **Bidirectional** — Encrypt requests and decrypt responses
- **Per-request control** — Disable via `HttpContext`
- **Error handling** — Configurable throw behavior on encryption/decryption errors
- **Header indication** — Adds header to indicate encrypted content

## Installation

```typescript
import { withEncryptionInterceptor, EncryptionAdapter } from 'ngx-oneforall/interceptors/encryption';
```

## Quick Start

### Create an Adapter

```typescript
const adapter: EncryptionAdapter = {
  encrypt: (data) => btoa(JSON.stringify(data)),
  decrypt: (data) => JSON.parse(atob(data as string))
};
```

### Register Interceptor

```typescript
provideHttpClient(
  withInterceptors([
    withEncryptionInterceptor({ adapter })
  ])
);
```

## Configuration

| Property | Type | Default | Description |
|----------|------|---------|-------------|
| `adapter` | `EncryptionAdapter` | **Required** | Encrypt/decrypt implementation |
| `enabled` | `boolean` | `true` | Enable encryption globally |
| `headerName` | `string` | `'X-Encrypted-Data'` | Header name for encrypted requests |
| `headerValue` | `string` | `'1'` | Header value when encrypted |
| `throwOnEncryptionError` | `boolean` | `true` | Throw if encryption fails |
| `throwOnDecryptionError` | `boolean` | `true` | Throw if decryption fails |

### EncryptionAdapter Interface

```typescript
interface EncryptionAdapter<T = unknown, E = unknown> {
  encrypt(data: T): E;
  decrypt(data: E): T;
}
```

## Error Handling

By default, errors during encryption/decryption are thrown. Set to `false` to fail silently:

```typescript
withEncryptionInterceptor({
  adapter,
  throwOnEncryptionError: false,  // Send unencrypted on failure
  throwOnDecryptionError: false   // Return raw response on failure
});
```

## Context API

```typescript
import { useEncryption } from 'ngx-oneforall/interceptors/encryption';
```

### Disable for a Request

```typescript
this.http.post('/api/public', data, {
  context: useEncryption({ enabled: false })
});
```

### Encrypt Only (No Decryption)

```typescript
this.http.post('/api/data', payload, {
  context: useEncryption({ decryptResponse: false })
});
```

### Context Options

| Property | Type | Default | Description |
|----------|------|---------|-------------|
| `enabled` | `boolean` | `true` | Enable/disable encryption |
| `encryptRequest` | `boolean` | `true` | Encrypt request body |
| `decryptResponse` | `boolean` | `true` | Decrypt response body |
| `context` | `HttpContext` | — | Extend existing context |

## Examples

### AES Encryption with CryptoJS

```typescript
import * as CryptoJS from 'crypto-js';

const aesAdapter: EncryptionAdapter = {
  encrypt: (data) => CryptoJS.AES.encrypt(JSON.stringify(data), SECRET).toString(),
  decrypt: (data) => JSON.parse(
    CryptoJS.AES.decrypt(data as string, SECRET).toString(CryptoJS.enc.Utf8)
  )
};
```

### Selective Encryption

```typescript
// Encrypt sensitive endpoints
this.http.put('/api/profile', profile);  // Encrypted

// Skip for public endpoints
this.http.get('/api/public', {
  context: useEncryption({ enabled: false })  // Not encrypted
});
```

> **Note**
> Always use HTTPS in addition to application-layer encryption.

> **Warning**
> The demo uses Base64 encoding for simplicity, which is NOT encryption. Use proper cryptographic algorithms in production.

## Demo

## Jwt Interceptor

**URL**: https://love1024.github.io/ngx-oneforall/interceptors/jwt
**Import**: `ngx-oneforall/interceptors/jwt`

The `withJwtInterceptor` attaches JWT tokens to outgoing HTTP requests for allowed domains.

## Features

- **Automatic token attachment** — Add JWT to requests automatically
- **Domain filtering** — Only attach tokens to allowed domains
- **Route exclusions** — Skip specific URLs
- **Token refresh (optional)** — Handle 401 errors with automatic refresh
- **Per-request control** — Disable via `HttpContext`
- **SSR-safe** — Skips on server-side rendering

## Installation

```typescript
import { withJwtInterceptor } from 'ngx-oneforall/interceptors/jwt';
```

## Quick Start

```typescript
provideHttpClient(
  withInterceptors([
    withJwtInterceptor({
      tokenGetter: () => localStorage.getItem('access_token')
    })
  ])
);
```

## Configuration

| Property | Type | Default | Description |
|----------|------|---------|-------------|
| `tokenGetter` | `() => string \| null` | **Required** | Function that returns the JWT |
| `authScheme` | `string` | `'Bearer '` | Prefix for the token |
| `headerName` | `string` | `'Authorization'` | Header name for the token |
| `allowedDomains` | `(string \| RegExp)[]` | `[]` | Domains to receive the token (empty = all allowed) |
| `skipUrls` | `(string \| RegExp)[]` | `[]` | URLs to exclude from token attachment |
| `skipAddingIfExpired` | `boolean` | `false` | Skip if token is expired |
| `errorOnNoToken` | `boolean` | `false` | Throw if no token available |
| `refreshTokenHandler` | `RefreshTokenHandler` | — | Handler for automatic token refresh |

> **Note**
> The current origin (`document.location.origin`) is always allowed, even if not in `allowedDomains`.

## Token Refresh

Handle 401 errors with automatic token refresh:

```typescript
withJwtInterceptor({
  tokenGetter: () => localStorage.getItem('token'),
  refreshTokenHandler: {
    refreshToken: () => authService.refresh(),
    logout: () => router.navigate(['/login'])
  }
});
```

### RefreshTokenHandler Interface

```typescript
interface RefreshTokenHandler {
  refreshToken(): Observable<string>;
  logout(): void;
}
```

### Refresh Behavior

- **Automatic retry** — Failed requests retry with new token
- **Deduplication** — Multiple 401s trigger only one refresh
- **Logout on failure** — Calls `logout()` if refresh fails
- **No handler = no refresh** — 401 errors propagate as-is

## Context API

```typescript
import { withSkipJwtInterceptor } from 'ngx-oneforall/interceptors/jwt';
```

### Skip for a Request

Bypass the interceptor for specific requests:

```typescript
// Skip for login request
this.http.post('/api/login', credentials, {
  context: withSkipJwtInterceptor()
});

// Skip for refresh token request
this.http.post('/api/auth/refresh', {}, {
  context: withSkipJwtInterceptor()
});
```

## Examples

### Basic Setup

```typescript
export const appConfig: ApplicationConfig = {
  providers: [
    provideHttpClient(
      withInterceptors([
        withJwtInterceptor({
          tokenGetter: () => localStorage.getItem('access_token')
        })
      ])
    )
  ]
};
```

### Domain Filtering

```typescript
withJwtInterceptor({
  tokenGetter: () => localStorage.getItem('token'),
  allowedDomains: [
    'api.example.com',
    'api-v2.example.com',
    /.*\.example\.com/  // Regex for subdomains
  ]
});
```

### Exclude Routes

```typescript
withJwtInterceptor({
  tokenGetter: () => localStorage.getItem('token'),
  skipUrls: [
    '/api/public',
    /\/api\/auth\/.*/  // Skip all auth routes
  ]
});
```

### Full Configuration

```typescript
withJwtInterceptor({
  tokenGetter: () => localStorage.getItem('access_token'),
  authScheme: 'Bearer ',
  headerName: 'Authorization',
  allowedDomains: ['api.example.com'],
  skipUrls: ['/api/public'],
  skipAddingIfExpired: true,
  errorOnNoToken: false,
  refreshTokenHandler: {
    refreshToken: () => this.authService.refresh().pipe(
      tap(token => localStorage.setItem('access_token', token))
    ),
    logout: () => {
      localStorage.clear();
      this.router.navigate(['/login']);
    }
  }
});
```

## Performance Interceptor

**URL**: https://love1024.github.io/ngx-oneforall/interceptors/performance
**Import**: `ngx-oneforall/interceptors/performance`

The `withPerformanceInterceptor` measures and reports HTTP request performance automatically.

## Features

- **Automatic timing** — Measures all HTTP requests
- **Slow detection** — Mark requests exceeding a threshold
- **Report control** — Only report slow requests if needed
- **Per-request control** — Disable or label via `HttpContext`
- **SSR-safe** — Falls back to `Date.now()` on server

## Installation

```typescript
import { withPerformanceInterceptor } from 'ngx-oneforall/interceptors/performance';
```

## Quick Start

```typescript
provideHttpClient(
  withInterceptors([
    withPerformanceInterceptor()
  ])
);
```

## Configuration

| Property | Type | Default | Description |
|----------|------|---------|-------------|
| `enabled` | `boolean` | `true` | Enable/disable reporting globally |
| `reporter` | `(entry) => void` | `console.debug` | Custom handler for performance entries |
| `slowThresholdMs` | `number` | — | Mark requests exceeding this duration as slow |
| `reportOnlyIfSlow` | `boolean` | `false` | Only report requests that exceed `slowThresholdMs` |

## PerformanceEntry

```typescript
interface PerformanceEntry {
  url: string;        // Request URL
  method: string;     // HTTP method
  durationMs: number; // Duration in milliseconds
  status?: number;    // HTTP status code
  label?: string;     // Custom label
  isSlow?: boolean;   // Exceeded slow threshold
}
```

## Custom Reporter

Reporters run in Angular's injection context, allowing `inject()`:

```typescript
withPerformanceInterceptor({
  reporter: entry => {
    const analytics = inject(AnalyticsService);
    analytics.track('http_request', entry);
  }
});
```

## Slow Request Detection

Mark and optionally filter slow requests:

```typescript
withPerformanceInterceptor({
  slowThresholdMs: 2000,      // 2 seconds
  reportOnlyIfSlow: true      // Only report slow requests
});
```

The default reporter prefixes slow requests with `[HTTP Performance - SLOW]`.

## Context API

```typescript
import { usePerformance } from 'ngx-oneforall/interceptors/performance';
```

### Disable for a Request

```typescript
this.http.get('/api/health', {
  context: usePerformance({ enabled: false })
});
```

### Add Custom Label

```typescript
this.http.post('/api/checkout', cart, {
  context: usePerformance({ label: 'Checkout Flow' })
});
```

### Context Options

| Option | Type | Description |
|--------|------|-------------|
| `enabled` | `boolean` | Disable reporting for this request |
| `label` | `string` | Custom label for identification |
| `context` | `HttpContext` | Existing context to extend |

## Examples

### Alert on Slow Requests

```typescript
withPerformanceInterceptor({
  slowThresholdMs: 2000,
  reporter: entry => {
    if (entry.isSlow) {
      const toast = inject(ToastService);
      toast.warn(`Slow: ${entry.url} took ${entry.durationMs}ms`);
    }
  }
});
```

### Analytics Integration

```typescript
withPerformanceInterceptor({
  reporter: entry => {
    const analytics = inject(AnalyticsService);
    analytics.track('performance', {
      url: entry.url,
      duration: entry.durationMs,
      status: entry.status,
      slow: entry.isSlow
    });
  }
});
```

### Production Slow-Only Monitoring

```typescript
withPerformanceInterceptor({
  slowThresholdMs: 3000,
  reportOnlyIfSlow: true,
  reporter: entry => {
    const logger = inject(LoggingService);
    logger.warn('Slow request', entry);
  }
});
```

## Demo

## Timeout Interceptor

**URL**: https://love1024.github.io/ngx-oneforall/interceptors/timeout
**Import**: `ngx-oneforall/interceptors/timeout`

The `withTimeoutInterceptor` adds automatic timeouts to HTTP requests.

## Features

- **Default timeout** — Apply timeout to all requests
- **Per-request override** — Context API for custom timeouts
- **Structured errors** — Typed error with request metadata

## Installation

```typescript
import { withTimeoutInterceptor } from 'ngx-oneforall/interceptors/timeout';
```

## Quick Start

```typescript
provideHttpClient(
  withInterceptors([
    withTimeoutInterceptor(30000) // 30 second default
  ])
);
```

## Per-Request Timeout

Override the default timeout for specific requests:

```typescript
import { withTimeout } from 'ngx-oneforall/interceptors/timeout';

this.http.get('/api/slow-endpoint', {
  context: withTimeout({ timeout: 60000 }) // 60 seconds
});
```

## Error Handling

```typescript
import { TIMEOUT_ERROR } from 'ngx-oneforall/interceptors/timeout';

this.http.get('/api/data').pipe(
  catchError(error => {
    if (error.name === TIMEOUT_ERROR) {
      console.error('Request timed out:', error.message);
    }
    return throwError(() => error);
  })
);
```

### TimeoutErrorInfo

```typescript
interface TimeoutErrorInfo {
  name: 'TimeoutError';        // Always 'TimeoutError'
  message: string;             // 'Request timed out after Xms'
  request: HttpRequest<unknown>;   // Original request
}
```

## Demo

---

# Pipes

## Bytes Pipe

**URL**: https://love1024.github.io/ngx-oneforall/pipes/bytes
**Import**: `ngx-oneforall/pipes/bytes`

The `BytesPipe` converts a number (in bytes) into a human-readable string with appropriate units (B, KB, MB, GB, TB, PB). It automatically selects the best unit and formats the number with configurable decimal places.

### Installation

```ts
import { BytesPipe } from 'ngx-oneforall/pipes/bytes';
```

### Usage

```html file="./snippets.html"#L2-L4
```

### Parameters

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `value` | `number \| string` | — | The bytes value to format |
| `decimals` | `number` | `2` | Decimal places in output |
| `units` | `string[] \| null` | `['B', 'KB', ...]` | Custom unit labels |
| `useSI` | `boolean` | `false` | Use SI base (1000) instead of binary (1024) |

### Binary vs SI Units

By default, the pipe uses **binary** base (1024):
- 1 KB = 1024 bytes
- 1 MB = 1,048,576 bytes

With `useSI: true`, use **SI** base (1000):
- 1 KB = 1000 bytes
- 1 MB = 1,000,000 bytes

```html file="./snippets.html"#L22-L24
```

### Examples

#### Custom Decimals

```html file="./snippets.html"#L8-L10
```

#### Custom Units

```html file="./snippets.html"#L18-L18
```

#### Large Numbers

```html file="./snippets.html"#L14-L14
```

### Edge Cases

- Handles negative numbers: `-1024` → `-1.00 KB`
- Returns `0 B` for invalid values (`NaN`, `null`, `undefined`, empty string)
- Caps at largest unit for very large numbers

---

#### Live Demo

## Call Pipe

**URL**: https://love1024.github.io/ngx-oneforall/pipes/call
**Import**: `ngx-oneforall/pipes/call`

The `CallPipe` invokes a function directly from the template with pure pipe caching. This prevents unnecessary change detection cycles since the function is only re-evaluated when its reference or arguments change.

### Installation

```ts
import { CallPipe } from 'ngx-oneforall/pipes/call';
```

### Usage

```html file="./snippets.html"#L2-L2
```

### Parameters

| Parameter | Type | Description |
|-----------|------|-------------|
| `fn` | `Function` | The function to call |
| `...args` | `unknown[]` | Arguments to pass to the function |

### Why Use CallPipe?

Without the pipe, functions in templates are called on every change detection:

```html
<!-- ❌ Called on every CD cycle -->
{% raw %}{% endraw %}

<!-- ✅ Called only when date changes -->
{% raw %}{% endraw %}
```

### Preserving Context

When using methods that rely on `this`, ensure the context is preserved:

#### Arrow Functions (Recommended)

Arrow functions automatically capture `this`:

```html file="./snippets.html"#L6-L6
```

#### Bound Methods

For regular methods, bind explicitly:

```typescript
// In component
getCounterBound = this.getCounter.bind(this);
```

```html file="./snippets.html"#L10-L10
```

### Behavior

- **Pure** - Only re-evaluates when function reference or arguments change
- **Type-safe** - Generic typing for better type inference
- **Null-safe** - Returns `null` if input is not a function

---

#### Live Demo

## First Error Key

**URL**: https://love1024.github.io/ngx-oneforall/pipes/first-error-key
**Import**: `ngx-oneforall/pipes/first-error-key`

The `FirstErrorKeyPipe` extracts the first validation error key from a form control's errors. It supports optional priority ordering to control which error displays first.

### Installation

```ts
import { FirstErrorKeyPipe } from 'ngx-oneforall/pipes/first-error-key';
```

### Usage

```html file="./demo/snippets.html"#L4-L6
```

### Parameters

| Parameter | Type | Description |
|-----------|------|-------------|
| `errors` | `ValidationErrors \| null` | Errors object from a form control |
| `priority` | `string[]` | Optional array of error keys in priority order |

### Priority Ordering

By default, returns the first error key in object order. With priority, returns the first matching priority key:

```html file="./demo/snippets.html"#L18-L22
```

**How it works:**
1. Iterates through priority array
2. Returns first key that exists in errors
3. Falls back to first available key if no matches

### Examples

#### Basic Usage

```html file="./demo/snippets.html"#L2-L7
```



#### With Error Messages

```html file="./demo/snippets.html"#L10-L13
```



### Behavior

- Returns empty string `''` if no errors
- Pure pipe - re-runs when errors object reference changes
- Always use `control.errors` (not `control`) for reactive updates

## Highlight Search

**URL**: https://love1024.github.io/ngx-oneforall/pipes/highlight-search
**Import**: `ngx-oneforall/pipes/highlight-search`

The `HighlightSearchPipe` highlights search matches by wrapping them in customizable HTML tags. Supports optional CSS classes for styling.

### Installation

```ts
import { HighlightSearchPipe } from 'ngx-oneforall/pipes/highlight-search';
```

### Usage

```html file="./snippets.html"#L2-L2
```

> **Note** Use `[innerHTML]` binding since this pipe returns HTML.

### Parameters

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `value` | `string \| null` | — | The text to search within |
| `search` | `string \| null` | — | The term to highlight |
| `tag` | `string` | `'mark'` | HTML tag to wrap matches |
| `cssClass` | `string` | — | Optional CSS class for wrapper |

### Examples

#### Basic Usage

```html file="./snippets.html"#L2-L3
```

#### Custom Tag

```html file="./snippets.html"#L6-L7
```

#### Custom CSS Class

```html file="./snippets.html"#L10-L14
```

#### Special Characters

The pipe escapes regex characters automatically:

```html file="./snippets.html"#L17-L18
```

### Behavior

- **Case insensitive** - Matches 'angular' in 'Angular'
- **Regex safe** - Escapes special characters (`$`, `+`, `?`, etc.)
- **Null safe** - Returns original value or empty string for null inputs

---

#### Live Demo

## Initials

**URL**: https://love1024.github.io/ngx-oneforall/pipes/initials
**Import**: `ngx-oneforall/pipes/initials`

The `initials` pipe transforms a name or string into its initials. It handles single or multiple words and allows customizing the number of initials returned.

### Installation

```ts
import { InitialsPipe } from 'ngx-oneforall/pipes/initials';
```

### Usage

```html file="./snippets.html"#L2-L3
```

### Examples

#### Basic Usage

```html file="./snippets.html"#L2-L3
```

#### Single Name

```html file="./snippets.html"#L6-L7
```

#### Custom Limit (1 Initial)

```html file="./snippets.html"#L10-L11
```

#### Custom Limit (3 Initials)

```html file="./snippets.html"#L14-L15
```

### Parameters

| Name | Type | Default | Description |
|------|------|---------|-------------|
| `value` | `string` | - | The input string to transform |
| `count` | `number` | `2` | The maximum number of initials to return |

### Live Demo

## Pluralize Pipe

**URL**: https://love1024.github.io/ngx-oneforall/pipes/pluralize
**Import**: `ngx-oneforall/pipes/pluralize`

The `PluralizePipe` handles word pluralization with automatic English rules and custom plural support.

### Installation

```ts
import { PluralizePipe } from 'ngx-oneforall/pipes/pluralize';
```

### Usage

```html file="./snippets.html"#L2-L5
```

### Parameters

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `value` | `number \| string` | — | The count to base pluralization on |
| `singular` | `string` | — | The singular form of the word |
| `plural` | `string \| null` | auto | Custom plural form (auto-generated if not provided) |
| `includeNumber` | `boolean` | `true` | Whether to prefix with the count |

### Auto-Pluralization Rules

When no custom plural is provided:
- Ends with `s`, `x`, `z`, `ch`, `sh` → adds `es` (box → boxes)
- Ends with consonant + `y` → changes to `ies` (city → cities)
- Otherwise → adds `s` (apple → apples)

### Examples

#### Custom Plural Form

```html file="./snippets.html"#L8-L9
```

#### Without Number

```html file="./snippets.html"#L12-L13
```

### Behavior

- Count `1` → singular form
- Count `0`, `2+`, decimals, negatives → plural form
- Throws error if singular form is empty

---

#### Live Demo

## Range Pipe

**URL**: https://love1024.github.io/ngx-oneforall/pipes/range
**Import**: `ngx-oneforall/pipes/range`

The `RangePipe` generates an array of numbers in a range. Follows Python's `range()` convention.

### Installation

```ts
import { RangePipe } from 'ngx-oneforall/pipes/range';
```

### Usage

```html file="./snippets.html"#L2-L5
```

### Parameters

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `start` | `number` | — | Start value (or end if `end` not provided) |
| `end` | `number` | — | End value (exclusive) |
| `step` | `number` | `1` | Step increment (direction auto-detected) |

### Examples

#### Start and End

```html file="./snippets.html"#L8-L11
```

#### With Step

```html file="./snippets.html"#L14-L17
```

#### Decreasing Range

```html file="./snippets.html"#L20-L23
```

### Behavior

| Input | Output |
|-------|--------|
| `5 \| range` | `[0, 1, 2, 3, 4]` |
| `1 \| range:5` | `[1, 2, 3, 4]` |
| `0 \| range:10:2` | `[0, 2, 4, 6, 8]` |
| `5 \| range:1` | `[5, 4, 3, 2]` |

- Step is normalized to positive (`Math.abs(step)`)
- Zero step defaults to 1 to prevent infinite loops
- Direction determined by comparing start and end

---

#### Live Demo

## Safe Html Pipe

**URL**: https://love1024.github.io/ngx-oneforall/pipes/safe-html
**Import**: `ngx-oneforall/pipes/safe-html`

The `SafeHtmlPipe` bypasses Angular's HTML sanitization to render trusted HTML content.

> **⚠️ Security Warning** Only use with trusted content. User input must be sanitized server-side.

### Installation

```ts
import { SafeHtmlPipe } from 'ngx-oneforall/pipes/safe-html';
```

### Usage

```html
<div [innerHTML]="htmlContent | safeHtml"></div>
```

### Parameters

| Parameter | Type | Description |
|-----------|------|-------------|
| `value` | `string \| null` | The HTML string to trust |

### When to Use

- **CMS content** - Admin-generated HTML from a trusted CMS
- **Markdown output** - Pre-rendered markdown that's already sanitized
- **Static HTML** - Hardcoded HTML strings in your codebase

### When NOT to Use

- **User input** - Never use with unsanitized user-provided content
- **External APIs** - Content from untrusted third-party sources
- **Query parameters** - URL parameters or form inputs

### Behavior

- Returns `SafeHtml` for valid strings
- Returns empty `SafeHtml` for `null`/`undefined`
- Throws error for non-string values

### How it Works

Uses Angular's `DomSanitizer.bypassSecurityTrustHtml()` to mark content as trusted. This bypasses XSS protection, so ensure content is safe before use.

---

#### Live Demo

## Time Ago Pipe

**URL**: https://love1024.github.io/ngx-oneforall/pipes/time-ago
**Import**: `ngx-oneforall/pipes/time-ago`

The `TimeAgoPipe` displays relative time (e.g., "2 hours ago", "in 3 days"). Supports live updates, future dates, and customizable labels.

### Installation

```ts
import { TimeAgoPipe } from 'ngx-oneforall/pipes/time-ago';
```

### Usage

```html file="./snippets.html"#L2-L2
```

### Parameters

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `value` | `string \| Date` | — | Date to calculate time from |
| `live` | `boolean` | `true` | Enable automatic updates |

### Features

| Output | Description |
|--------|-------------|
| `just now` | Within 10 seconds |
| `X seconds ago` | Within 1 minute |
| `X minutes ago` | Within 1 hour |
| `X hours ago` | Within 1 day |
| `X days ago` | Within 1 week |
| `X weeks ago` | Within 1 month |
| `X months ago` | Within 1 year |
| `X years ago` | Over 1 year |
| `in X seconds` | Future within 1 minute |
| `in X days` | Future date |

### Examples

#### Basic Usage



#### Disable Live Updates

```html file="./snippets.html"#L5-L5
```

#### Future Dates

```html file="./snippets.html"#L8-L9
```

### Custom Labels

Use `provideTimeAgoPipeLabels` to customize:

```typescript
providers: [
  provideTimeAgoPipeLabels(() => ({
    prefix: '',
    suffix: 'ago',
    futurePrefix: 'in',
    futureSuffix: '',
    justNow: 'just now',
    second: 'sec',
    seconds: 'secs',
    // ... other labels
  })),
]
```



### Custom Clock

Control update frequency:

```typescript
providers: [
  provideTimeAgoPipeClock(() => timer(5000)), // Update every 5 seconds
]
```

## Truncate Pipe

**URL**: https://love1024.github.io/ngx-oneforall/pipes/truncate
**Import**: `ngx-oneforall/pipes/truncate`

The `TruncatePipe` shortens strings to a specified length with optional word boundary and position support.

### Installation

```ts
import { TruncatePipe } from 'ngx-oneforall/pipes/truncate';
```

### Usage

```html file="./snippets.html"#L2-L2
```

### Parameters

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `value` | `string \| null` | — | The string to truncate |
| `limit` | `number` | `100` | Maximum character length |
| `completeWords` | `boolean` | `false` | Truncate at word boundary (end only) |
| `ellipsis` | `string` | `'…'` | String to append/insert when truncated |
| `position` | `'start' \| 'middle' \| 'end'` | `'end'` | Where to truncate |

### Examples

#### End Truncation (default)

```html file="./snippets.html"#L5-L6
```

#### Start Truncation

```html file="./snippets.html"#L9-L10
```

#### Middle Truncation

```html file="./snippets.html"#L13-L14
```

#### Complete Words

```html file="./snippets.html"#L17-L18
```

### Behavior

| Position | Example (limit: 8) | Output |
|----------|-------------------|--------|
| `end` | `Hello World` | `Hello Wo…` |
| `start` | `Hello World` | `…lo World` |
| `middle` | `Hello World` | `Hell…rld` |

- `completeWords` only applies to end truncation
- Returns empty string for `null`/`undefined` or `limit <= 0`

---

#### Live Demo

---

# RxJS

## Backoff Retry

**URL**: https://love1024.github.io/ngx-oneforall/rxjs/backoff-retry
**Import**: `ngx-oneforall/rxjs/backoff-retry`

The `backOffRetry` RxJS operator automatically retries failed observables with an exponential backoff strategy. It is essential for handling transient failures in network requests or unstable services.

## Features

- **Exponential Backoff** — Increases delay between retries exponentially
- **Customizable Strategy** — Configure max retries, initial delay, and multiplier base
- **Typed Configuration** — Full TypeScript support for configuration
- **Seamless Integration** — Works with any RxJS observable

## Installation

```typescript
import { backOffRetry } from 'ngx-oneforall/rxjs/backoff-retry';
```

## Quick Start

```typescript
this.http.get('/api/data').pipe(
  backOffRetry()
).subscribe();
```

## Configuration

The operator accepts an optional `BackoffRetryConfig` object:

| Property | Type | Default | Description |
|----------|------|---------|-------------|
| `count` | `number` | `3` | Maximum number of retry attempts |
| `delay` | `number` | `1000` | Initial delay in milliseconds |
| `base` | `number` | `2` | Base for exponential calculation |
| `maxDelay` | `number` | - | Optional cap for maximum delay (in ms) |

### Custom Configuration

```typescript
this.http.get('/api/unstable').pipe(
  backOffRetry({
    count: 5,       // Retry 5 times
    delay: 500,     // Start with 500ms delay
    base: 1.5       // Increase delay by 1.5x each time
  })
).subscribe();
```

### With Max Delay Cap

Prevent delays from growing too large:

```typescript
this.http.get('/api/data').pipe(
  backOffRetry({
    count: 10,       // Many retries
    delay: 1000,     // Start at 1 second
    base: 2,         // Double each time
    maxDelay: 30000  // But never wait more than 30 seconds
  })
).subscribe();
// Delays: 1s, 2s, 4s, 8s, 16s, 30s, 30s, 30s, 30s, 30s
```

## How It Works

The delay for each retry is calculated using the formula:

`min(delay * Math.pow(base, retryCount - 1), maxDelay)`

For default values (`delay=1000`, `base=2`):
- **Retry 1**: 1000ms
- **Retry 2**: 2000ms
- **Retry 3**: 4000ms

## Examples

### Robust API Calls

Wrap your HTTP requests to automatically recover from temporary network glitches:

```typescript
import { catchError } from 'rxjs/operators';
import { of } from 'rxjs';

this.http.get('/api/users').pipe(
  backOffRetry(),
  catchError(err => {
    console.error('All retries failed', err);
    return of([]); // Fallback value
  })
).subscribe();
```

### With Other Operators

Combine with other operators for advanced flows:

```typescript
this.source$.pipe(
  // Custom logic before retry
  tap({ error: () => console.log('Retrying...') }),
  backOffRetry({ count: 2 }),
  // Logic after all retries fail
  catchError(err => throwError(() => new Error('Service Unavailable')))
);
```

## Demo

See the operator in action with visualized retry attempts:

## Catch Error With Fallback

**URL**: https://love1024.github.io/ngx-oneforall/rxjs/catch-error-with-fallback
**Import**: `ngx-oneforall/rxjs/catch-error-with-fallback`

The `catchErrorWithFallback` operator provides a clean, flexible way to handle errors in RxJS streams by automatically switching to a fallback value, observable, or dynamically generated result when an error occurs.

## Why Use catchErrorWithFallback?

Error handling is essential for robust applications, but RxJS's native `catchError` requires manually wrapping fallback values in `of()` observables. This operator simplifies the pattern:

- **Cleaner Code**: No need to wrap static values in `of()`
- **Flexible Fallbacks**: Support for static values, observables, or factory functions
- **Error Callbacks**: Optional `onError` hook for logging or side effects
- **Type Safety**: Full TypeScript support with proper type inference
- **Dynamic Responses**: Factory functions can use the error to determine the fallback

## How to Use

Import the operator from `ngx-oneforall/rxjs`:

```typescript
import { catchErrorWithFallback } from 'ngx-oneforall/rxjs/catch-error-with-fallback';
```

### Basic Usage with Static Fallback

```typescript
this.http.get<User>('/api/user').pipe(
  catchErrorWithFallback({ id: 0, name: 'Guest' })
).subscribe(user => {
  console.log(user); // Either API data or fallback guest user
});
```

### Using an Observable Fallback

```typescript
this.http.get<Post[]>('/api/posts').pipe(
  catchErrorWithFallback(this.getCachedPosts())
).subscribe(posts => {
  // Falls back to cached posts on error
});
```

### Dynamic Fallback with Factory Function

```typescript
this.http.delete(`/api/items/${id}`).pipe(
  catchErrorWithFallback((error) => {
    if (error.status === 404) {
      return { success: true, message: 'Already deleted' };
    }
    return { success: false, message: 'Delete failed' };
  })
).subscribe(result => {
  console.log(result.message);
});
```

### With Error Logging

```typescript
this.http.get<Data>('/api/data').pipe(
  catchErrorWithFallback([], {
    onError: (err) => console.error('API failed:', err)
  })
).subscribe(data => {
  // Empty array as fallback, error logged
});
```

## API

### Signature

```typescript
function catchErrorWithFallback<T>(
  fallback: FallbackFactory<T>,
  options?: CatchErrorWithFallbackOptions
): OperatorFunction<T, T>
```

### Parameters

| Parameter | Type | Description |
|-----------|------|-------------|
| `fallback` | `FallbackFactory<T>` | Static value, observable, or factory function |
| `options` | `CatchErrorWithFallbackOptions` | Optional configuration |

### FallbackFactory Type

```typescript
type FallbackFactory<T> =
  | T                                    // Static value
  | Observable<T>                        // Observable
  | ((error: unknown) => T | Observable<T>);  // Factory function
```

### Options

| Option | Type | Description |
|--------|------|-------------|
| `onError` | `(error: unknown) => void` | Callback invoked when an error is caught |

## Behavior

The operator follows these rules:

1. **Pass-Through**: If no error occurs, values pass through unchanged
2. **Static Fallback**: Plain values are automatically wrapped in `of()`
3. **Observable Fallback**: Observables are subscribed to directly
4. **Factory Functions**: Executed with the error, return value wrapped if needed
5. **Error Callback**: `onError` is called before the fallback is applied

## Use Cases

### API with Fallback Data

```typescript
class ProductService {
  getProducts(): Observable<Product[]> {
    return this.http.get<Product[]>('/api/products').pipe(
      catchErrorWithFallback(this.getDefaultProducts())
    );
  }

  private getDefaultProducts(): Product[] {
    return [
      { id: 1, name: 'Sample Product', price: 0 }
    ];
  }
}
```

### Graceful Degradation

```typescript
this.configService.getRemoteConfig().pipe(
  catchErrorWithFallback({
    theme: 'light',
    language: 'en',
    features: []
  }, {
    onError: (err) => this.logger.warn('Using default config', err)
  })
).subscribe(config => {
  this.applyConfig(config);
});
```

### Error-Specific Handling

```typescript
this.http.post('/api/payment', paymentData).pipe(
  catchErrorWithFallback((error: any) => {
    if (error.status === 429) {
      return of({ retryAfter: error.headers.get('Retry-After') });
    }
    if (error.status >= 500) {
      return of({ serverError: true });
    }
    return throwError(() => error); // Re-throw client errors
  })
)
```

### Logging and Metrics

```typescript
this.dataService.fetchCriticalData().pipe(
  catchErrorWithFallback(this.getCachedData(), {
    onError: (err) => {
      this.analytics.trackError('critical_data_fetch_failed', err);
      this.notifySupport(err);
    }
  })
)
```

### Form Submission with Retry

```typescript
submitForm(data: FormData): Observable<SubmitResult> {
  return this.http.post<SubmitResult>('/api/submit', data).pipe(
    catchErrorWithFallback((error: any) => {
      // Return observable for async retry logic
      return of(null).pipe(
        delay(2000),
        switchMap(() => this.http.post<SubmitResult>('/api/submit', data))
      );
    }, {
      onError: (err) => console.warn('First attempt failed, retrying...')
    })
  );
}
```

## Comparison with Native catchError

### Native RxJS

```typescript
// Verbose - must wrap in of()
source$.pipe(
  catchError(error => {
    console.error(error);
    return of(defaultValue);
  })
)
```

### With catchErrorWithFallback

```typescript
// Concise - automatic wrapping
source$.pipe(
  catchErrorWithFallback(defaultValue, {
    onError: error => console.error(error)
  })
)
```

## Demo

Explore the operator with an interactive demonstration:

## Data Polling

**URL**: https://love1024.github.io/ngx-oneforall/rxjs/data-polling
**Import**: `ngx-oneforall/rxjs/data-polling`

`dataPolling` is an RxJS operator that automatically polls a data source at specified intervals.

It uses `timer` and `switchMap` to repeatedly call a loader function, making it perfect for real-time data updates.

## Usage

{{ NgDocActions.demo("DataPollingDemoComponent", { container: true }) }}

### Basic Example

```typescript
import { Subject } from 'rxjs';
import { dataPolling } from 'ngx-oneforall/rxjs/data-polling';

const trigger = new Subject<void>();

trigger.pipe(
    dataPolling({
        loader: () => fetchData(), // Your data fetching function
        interval: 5000 // Poll every 5 seconds
    })
).subscribe(data => {
    console.log('Received data:', data);
});

// Start polling
trigger.next();
```

### With HTTP Requests

```typescript
import { HttpClient } from '@angular/common/http';
import { Subject } from 'rxjs';
import { dataPolling } from 'ngx-oneforall/rxjs/data-polling';

export class MyComponent {
    constructor(private http: HttpClient) {}

    startPolling() {
        const trigger = new Subject<void>();
        
        trigger.pipe(
            dataPolling({
                loader: () => this.http.get('/api/status'),
                interval: 10000 // Poll every 10 seconds
            })
        ).subscribe(status => {
            console.log('Server status:', status);
        });

        trigger.next();
    }
}
```

## API

`dataPolling<T>(config: DataPollingConfig<T>): OperatorFunction<unknown, T>`

### Configuration

| Property | Type | Default | Description |
|----------|------|---------|-------------|
| `loader` | `() => Observable<T>` | - | Function that returns an Observable of the data to poll |
| `interval` | `number` | - | Polling interval in milliseconds |
| `retryCount` | `number` | `0` | Number of retry attempts on error |
| `retryDelay` | `number` | `1000` | Delay between retries in milliseconds |

### Behavior

- Immediately calls the loader when the source emits
- Continues polling at the specified interval
- Cancels previous polling if the source emits again
- Retries failed requests up to `retryCount` times with `retryDelay` between attempts

### Example with Retry

```typescript
trigger.pipe(
    dataPolling({
        loader: () => this.http.get('/api/data'),
        interval: 5000,
        retryCount: 3,  // Retry up to 3 times
        retryDelay: 1000 // Wait 1 second between retries
    })
).subscribe(data => console.log(data));
```

## Debug

**URL**: https://love1024.github.io/ngx-oneforall/rxjs/debug
**Import**: `ngx-oneforall/rxjs/debug`

`debug` is a utility operator that provides styled logging for RxJS streams. It wraps the `tap` operator to log `next`, `error`, and `complete` events with a custom tag and distinct CSS styles, making it easier to debug complex observable chains in the browser console.

## Usage

{{ NgDocActions.demo("DebugDemoComponent", { container: true }) }}

### Basic Example

```typescript
import { of } from 'rxjs';
import { debug } from 'ngx-oneforall/rxjs/debug';

const source$ = of(1, 2, 3).pipe(
    debug('NumbersStream')
);

source$.subscribe();
// Console output:
// [NumbersStream: Next] 1
// [NumbersStream: Next] 2
// [NumbersStream: Next] 3
// [NumbersStream]: Complete
```

## API

`debug<T>(tag: string, when?: (value?: T) => boolean): MonoTypeOperatorFunction<T>`

### Parameters

- **tag**: A string label that identifies the stream in the console output.
- **when**: (Optional) A function that returns a boolean. Logging only occurs if this function returns `true`. It receives the emitted value as an argument (for `next` events).

### Examples

#### Conditional Logging

```typescript
import { of } from 'rxjs';
import { debug } from 'ngx-oneforall/rxjs/debug';

const isDev = true;
const source$ = of('data').pipe(
    debug('MyStream', () => isDev)
);
```

#### Filtering Logs by Value

```typescript
const source$ = of(1, 10, 100).pipe(
    debug('BigNumbers', (val) => val >= 10)
);
// Only 10 and 100 will be logged.
```

### Console Styles

The operator uses different console methods and colors to help you distinguish between event types:


- **Next**: `console.log` - Cyan background with white text.
- **Error**: `console.error` - Pinkish-red background with white text.
- **Complete**: `console.info` - Teal background with white text.

### Benefits

- **Visibility**: Easily spot your stream logs among other console output.
- **No Boilerplate**: Replaces multiple `tap(val => console.log(val))` calls with a single operator.
- **State Tracking**: Automatically handles error and completion logging without extra code.

## Live Search

**URL**: https://love1024.github.io/ngx-oneforall/rxjs/live-search
**Import**: `ngx-oneforall/rxjs/live-search`

`liveSearch` is an RxJS operator for implementing live search functionality with automatic debouncing, duplicate filtering, and request cancellation.

It combines `debounceTime`, `distinctUntilChanged`, and `switchMap` to provide an optimal search experience.

## Usage

{{ NgDocActions.demo("LiveSearchDemoComponent", { container: true }) }}

### Basic Example

```typescript
import { FormControl } from '@angular/forms';
import { liveSearch } from 'ngx-oneforall/rxjs/live-search';

export class SearchComponent {
    searchControl = new FormControl('', { nonNullable: true });

    ngOnInit() {
        this.searchControl.valueChanges.pipe(
            liveSearch(300, (query) => this.searchAPI(query))
        ).subscribe(results => {
            console.log('Search results:', results);
        });
    }

    private searchAPI(query: string) {
        return this.http.get(`/api/search?q=${query}`);
    }
}
```

### With HttpClient

```typescript
import { HttpClient } from '@angular/common/http';
import { FormControl } from '@angular/forms';
import { liveSearch } from 'ngx-oneforall/rxjs/live-search';

export class ProductSearchComponent {
    searchControl = new FormControl('');
    results$ = this.searchControl.valueChanges.pipe(
        liveSearch(500, (query) => this.searchProducts(query))
    );

    constructor(private http: HttpClient) {}

    private searchProducts(query: string) {
        return this.http.get<Product[]>(`/api/products/search`, {
            params: { q: query }
        });
    }
}
```

## API

`liveSearch<T>(delay: number, dataProducer: (query: string) => Observable<T>)`

### Parameters

- **delay**: Debounce delay in milliseconds
- **dataProducer**: A function that takes the query string and returns an Observable of search results

### Behavior

- Debounces input to reduce API calls
- Filters out consecutive duplicate values
- Automatically cancels previous search requests when a new one is initiated
- The delay is specified in **milliseconds**

### Benefits

- Reduces server load by debouncing rapid input changes
- Prevents duplicate searches
- Always shows the most recent search results
- Handles race conditions automatically

## Loading Status

**URL**: https://love1024.github.io/ngx-oneforall/rxjs/loading-status
**Import**: `ngx-oneforall/rxjs/loading-status`

`loadingStatus` is an RxJS operator that simplifies tracking the state of an asynchronous operation (like an API call). It automatically catches errors and provides a unified `ResourceResult<T>` object containing the loading status, the data, and any potential error.

## Usage

{{ NgDocActions.demo("LoadingStatusDemoComponent", { container: true }) }}

### Basic Example


In your component, you can then easily handle the different states:

{% raw %}
```html file="./snippet.html"#L1-L13
```
{% endraw %}

## API

`loadingStatus<T>(): OperatorFunction<T, ResourceResult<T>>`

### ResourceResult<T> Interface

```typescript
type ResourceResult<T> = {
    isLoading: boolean;
    status: 'loading' | 'success' | 'error';
    data: T | null;
    error?: unknown;
}
```

### Behavior

- **Initial State**: Immediately emits `{ status: 'loading', data: null, isLoading: true }` upon subscription.
- **Success State**: When the source observable emits data, it transforms it to `{ status: 'success', data: T, isLoading: false }`.
- **Error State**: If the source observable errors, it catches it and emits `{ status: 'error', data: null, error: unknown, isLoading: false }`.

### Benefits

- **Unified State**: No need to manage separate `isLoading`, `error`, and `data` variables or signals.
- **Error Handling**: Automatically catches errors so the stream doesn't terminate unexpectedly (it transforms the error into a value).
- **Type Safety**: Provides a strongly typed result object.

---

# Services

## Cache

**URL**: https://love1024.github.io/ngx-oneforall/services/cache
**Import**: `ngx-oneforall/services/cache`

Advanced caching service with TTL, versioning, and multi-storage support.

## Features

- **Multi-Storage** — Support for `memory`, `local`, and `session` storage
- **Time-to-Live (TTL)** — Auto-expiration for cached entries
- **Versioning** — Invalidate entire cache when version changes
- **SSR Safe** — Graceful fallback to memory on server
- **Type-Safe** — Generic support for stored values

---

## Installation

```typescript
import { 
  CacheService, 
  provideCacheService,
  CacheOptions 
} from 'ngx-oneforall/services/cache';
```

---

## Basic Usage

```typescript
import { Component, inject } from '@angular/core';
import { CacheService, provideCacheService } from 'ngx-oneforall/services/cache';

@Component({
  selector: 'app-demo',
  template: `<p>User:  user() }}</p>`,
  providers: [
    provideCacheService({
      storage: 'local',
      ttl: 3600 * 1000, // 1 hour
      version: 'v1.0.0'
    })
  ]
})
export class DemoComponent {
  private cache = inject(CacheService);

  user = linkedSignal(() => {
    // Check cache first
    const cached = this.cache.get<User>('current_user');
    if (cached) return cached;
    
    // Fetch if missing
    return this.fetchUser();
  });

  saveUser(user: User) {
    this.cache.set('current_user', user);
  }
}
```

---

## API Reference

### `get<T>(key, storage?)`

Retrieve a value from cache. Returns `null` if missing or expired.

```typescript
// Get from default storage
const value = cache.get<string>('key');

// Get from specific storage
const memoryValue = cache.get<number>('count', 'memory');
```

### `set<T>(key, value, config?)`

Store a value with optional overrides.

```typescript
// Use global config
cache.set('user', user);

// Override TTL for this specific item (e.g. 5 seconds)
cache.set('temp', data, { ttl: 5000 });
```

### `has(key, storage?)`

Check if a valid (non-expired) entry exists.

```typescript
if (cache.has('token')) {
  // ...
}
```

### `remove(key, storage?)`

Remove a specific entry.

### `clear(storage?)`

Clear all entries managed by this service (respects prefix).

---

## Configuration Options

Pass these options to `provideCacheService()`:

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `storage` | `'memory' \| 'local' \| 'session'` | `'memory'` | Default storage engine |
| `ttl` | `number` | `3600000` (1h) | Global expiration time in ms |
| `version` | `string` | `INTERNAL` | Cache version string |
| `storagePrefix` | `string` | `undefined` | Key prefix in storage |

---

## Versioning & Invalidation

When you deploy a new version of your app, you often want to invalidate old cache entries to prevent schema mismatches.

```typescript
provideCacheService({
  version: 'v2.0.0', // Changing this invalidates all previous 'v1.0.0' entries
})
```

When `CacheService` detects a version mismatch for a key, it automatically removes that entry and returns `null`.

---

## Live Demo

## Clipboard

**URL**: https://love1024.github.io/ngx-oneforall/services/clipboard
**Import**: `ngx-oneforall/services/clipboard`

A simple service for copying and reading text from the system clipboard with automatic fallback for older browsers.

## Features

- **Modern Clipboard API** — Uses `navigator.clipboard` when available
- **Automatic Fallback** — Falls back to `execCommand('copy')` for older browsers
- **SSR Safe** — Returns safe defaults on server
- **Promise-based** — Async/await friendly API

---

## Installation

```typescript
import { ClipboardService } from 'ngx-oneforall/services/clipboard';
```

---

## Basic Usage

```typescript
import { Component, inject } from '@angular/core';
import { ClipboardService } from 'ngx-oneforall/services/clipboard';

@Component({
  selector: 'app-demo',
  template: `
    <button (click)="copyText()">Copy</button>
    <button (click)="pasteText()">Paste</button>
  `,
  providers: [ClipboardService],
})
export class DemoComponent {
  private clipboard = inject(ClipboardService);

  async copyText() {
    const success = await this.clipboard.copy('Hello World');
    console.log(success ? 'Copied!' : 'Failed to copy');
  }

  async pasteText() {
    const text = await this.clipboard.read();
    console.log('Clipboard:', text);
  }
}
```

---

## API Reference

| Method | Returns | Description |
|--------|---------|-------------|
| `copy(text)` | `Promise<boolean>` | Copies text to clipboard, returns `true` on success |
| `read()` | `Promise<string>` | Reads text from clipboard, returns `''` on failure |

---

## SSR Behavior

On server-side rendering (SSR):

| Method | SSR Return |
|--------|------------|
| `copy()` | `false` |
| `read()` | `''` |

---

## Browser Compatibility

> [!NOTE]
> The Clipboard API requires user interaction and HTTPS. On HTTP or without user gesture, the fallback mechanism will be used for `copy()`.

---

## Live Demo

## Cookie

**URL**: https://love1024.github.io/ngx-oneforall/services/cookie
**Import**: `ngx-oneforall/services/cookie`

A lightweight service for managing browser cookies with SSR safety and security-aware defaults.

## Features

- **CRUD Operations** — Get, set, delete individual or all cookies
- **SSR Safe** — Returns safe defaults on server (no `document` access)
- **Security Compliant** — Auto-enforces `secure` flag when `SameSite=None`
- **Flexible Options** — Expiry, path, domain, partitioned, and more

---

## Installation

```typescript
import { CookieService, provideCookieService } from 'ngx-oneforall/services/cookie';
```

---

## Basic Usage

```typescript
import { Component, inject } from '@angular/core';
import { CookieService, provideCookieService } from 'ngx-oneforall/services/cookie';

@Component({
  selector: 'app-demo',
  template: `<button (click)="save()">Save</button>`,
  providers: [provideCookieService()],
})
export class DemoComponent {
  private cookies = inject(CookieService);

  save() {
    // Set cookie with 1 hour expiry
    this.cookies.set('user', 'JohnDoe', { expires: 3600 });
    
    // Get cookie value
    const user = this.cookies.get('user'); // 'JohnDoe'
    
    // Delete cookie
    this.cookies.delete('user');
  }
}
```

---

## API Reference

| Method | Returns | Description |
|--------|---------|-------------|
| `get(name)` | `string` | Returns cookie value or `''` if not found |
| `getAll()` | `Record<string, string>` | Returns all cookies as key-value object |
| `set(name, value, options?)` | `void` | Sets a cookie with optional config |
| `delete(name, options?)` | `void` | Deletes the specified cookie |
| `deleteAll(options?)` | `void` | Deletes all cookies |

---

## Cookie Options

```typescript
interface CookieOptions {
  sameSite?: 'Strict' | 'Lax' | 'None';  // Default: 'Lax'
  domain?: string;
  path?: string;
  secure?: boolean;
  partitioned?: boolean;
  expires?: number | Date;  // number = seconds
}
```

---

## SSR Behavior

On server-side rendering (SSR), all methods return safe defaults:

| Method | SSR Return |
|--------|------------|
| `get()` | `''` |
| `getAll()` | `{}` |
| `set()` / `delete()` / `deleteAll()` | No-op |

---

## Security Notes

> [!WARNING]
> When `SameSite=None` is set, the service automatically enables `secure: true` and logs a console warning. This is required by browser security policies.

---

## Live Demo

## Device

**URL**: https://love1024.github.io/ngx-oneforall/services/device
**Import**: `ngx-oneforall/services/device`

Detect device type and orientation with automatic updates on resize and orientation changes.

## Features

- **Device Type Detection** — Detect `mobile`, `tablet`, or `desktop`
- **Orientation Detection** — Detect `portrait` or `landscape`
- **Reactive Signal** — Exposes `deviceInfoSignal` for template bindings
- **SSR Safe** — No window subscriptions on server

---

## Installation

```typescript
import { DeviceService, provideDeviceService } from 'ngx-oneforall/services/device';
```

---

## Basic Usage

```typescript
import { Component, inject } from '@angular/core';
import { DeviceService, provideDeviceService } from 'ngx-oneforall/services/device';

@Component({
  selector: 'app-demo',
  template: `
    @if (device.deviceInfoSignal(); as info) {
      <p>Type: </p>
      <p>Orientation: </p>
    }
  `,
  providers: [provideDeviceService()],
})
export class DemoComponent {
  device = inject(DeviceService);
}
```

---

## API Reference

### Properties

| Property | Type | Description |
|----------|------|-------------|
| `deviceInfo` | `DeviceInfo \| null` | Current device info object |
| `deviceType` | `DeviceType \| null` | `'mobile'` \| `'tablet'` \| `'desktop'` |
| `orientation` | `Orientation \| null` | `'portrait'` \| `'landscape'` |
| `deviceInfoSignal` | `Signal<DeviceInfo \| null>` | Reactive signal for templates |

### Methods

| Method | Returns | Description |
|--------|---------|-------------|
| `isMobile()` | `boolean` | True if device is mobile |
| `isTablet()` | `boolean` | True if device is tablet |
| `isDesktop()` | `boolean` | True if device is desktop |
| `isPortrait()` | `boolean` | True if orientation is portrait |
| `isLandscape()` | `boolean` | True if orientation is landscape |

---

## Types

```typescript
interface DeviceInfo {
  type: 'mobile' | 'tablet' | 'desktop';
  orientation: 'portrait' | 'landscape';
}
```

---

## Detection Strategy

1. **userAgentData** — Most accurate (Chromium browsers)
2. **iPadOS detection** — Handles iPadOS 13+ (reports as Macintosh)
3. **User Agent regex** — Fallback pattern matching
4. **Touch + screen size** — Final fallback for unknown devices

---

## SSR Behavior

On server-side rendering:
- `deviceInfo`, `deviceType`, `orientation` return `null`
- No window event subscriptions are created

---

## Live Demo

## Event

**URL**: https://love1024.github.io/ngx-oneforall/services/event-service
**Import**: `ngx-oneforall/services/event-service`

A lightweight pub-sub service for event-based communication between Angular components and services.

## Features

- **Dispatch Events** — Publish custom events with optional typed payloads
- **Type-Safe Subscriptions** — Use generics for typed event data
- **Decoupled Communication** — No direct component references needed
- **SSR Safe** — Works in server-side rendering environments

---

## Installation

```typescript
import { EventService, provideEventService, AppEvent } from 'ngx-oneforall/services/event';
```

---

## Basic Usage

```typescript
import { Component, inject } from '@angular/core';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';
import { EventService, provideEventService } from 'ngx-oneforall/services/event';

@Component({
  selector: 'app-demo',
  template: `
    <button (click)="sendEvent()">Send Event</button>
    @if (lastEvent) {
      <p>Last: </p>
    }
  `,
  providers: [provideEventService()],
})
export class DemoComponent {
  private events = inject(EventService);
  lastEvent?: { name: string; data?: unknown };

  constructor() {
    this.events.getEventEmitter()
      .pipe(takeUntilDestroyed())
      .subscribe(event => this.lastEvent = event);
  }

  sendEvent() {
    this.events.dispatchEvent('myEvent', { foo: 'bar' });
  }
}
```

---

## Type-Safe Events

Use generics to get typed event data:

```typescript
interface UserData {
  userId: string;
  name: string;
}

// Typed subscription
this.events.getEventEmitter<UserData>().subscribe(event => {
  console.log(event.data?.userId);  // ✅ typed as string
  console.log(event.data?.name);    // ✅ typed as string
});

// Dispatch with matching type
this.events.dispatchEvent('user:login', { userId: '123', name: 'John' });
```

---

## API Reference

| Method | Returns | Description |
|--------|---------|-------------|
| `dispatchEvent(name, data?)` | `void` | Dispatches an event with name and optional data |
| `getEventEmitter<T>()` | `Observable<AppEvent<T>>` | Returns typed observable stream of events |

---

## Types

```typescript
interface AppEvent<T = unknown> {
  name: string;
  data?: T;
}
```

---

## When to Use

- Cross-component communication without parent-child relationship
- Decoupling event producers from consumers
- Broadcasting state changes to multiple subscribers

---

## Live Demo

## History

**URL**: https://love1024.github.io/ngx-oneforall/services/history
**Import**: `ngx-oneforall/services/history`

`HistoryService` tracks navigation and provides back navigation with fallback support.

## Features

- **Navigation Tracking** — Tracks route changes after calling `startTracking()`
- **Previous URL** — Access the previous page URL
- **Back with Fallback** — Go back or navigate to fallback if no history
- **Replace Navigation** — Navigate without adding to history
- **SSR Safe** — Does nothing on server-side

---

## Installation

```typescript
import { provideHistoryService, HistoryService } from 'ngx-oneforall/services/history';

// app.config.ts
export const appConfig: ApplicationConfig = {
  providers: [
    provideHistoryService({ maxSize: 100 }),
  ],
};

// app.component.ts - Start tracking
constructor() {
  inject(HistoryService).startTracking();
}
```

---

## API Reference

### Configuration

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `maxSize` | `number` | `50` | Maximum history entries to keep |

### Service Methods

| Method | Returns | Description |
|--------|---------|-------------|
| `startTracking()` | `void` | Start tracking navigation events |
| `back()` | `void` | Navigate back if possible |
| `backOrFallback(url)` | `void` | Go back or navigate to fallback URL |
| `forward()` | `void` | Navigate forward |
| `replaceCurrent(url)` | `Promise<boolean>` | Navigate without adding to history |
| `clear()` | `void` | Clear history stack |
| `getHistory()` | `string[]` | Get full history array |

### Signals

| Signal | Type | Description |
|--------|------|-------------|
| `currentUrl()` | `string \| null` | Current URL |
| `previousUrl()` | `string \| null` | Previous URL |
| `canGoBack()` | `boolean` | Whether back is possible |
| `length()` | `number` | History stack size |

---

## Basic Usage

```typescript
@Component({...})
export class MyComponent {
  private history = inject(HistoryService);

  goBack() {
    this.history.backOrFallback('/home');
  }

  handleLoginSuccess() {
    // Replace login page in history
    this.history.replaceCurrent('/dashboard');
  }
}
```

---

## Live Demo

## Idle

**URL**: https://love1024.github.io/ngx-oneforall/services/idle
**Import**: `ngx-oneforall/services/idle`

`IdleService` detects user inactivity based on DOM events (mouse, keyboard, touch, scroll).

## Features

- **Signal & Observable API** — Exposes `isIdle` signal and `isIdle$` observable
- **Configurable** — Customize timeout duration and monitored events
- **SSR Safe** — No listeners attached on server
- **Passive Events** — Uses passive event listeners for better performance
- **Auto Cleanup** — Automatically stops on component/service destroy
---

## Usage

```typescript
import { IdleService, provideIdleService } from 'ngx-oneforall/services/idle';

@Component({
  providers: [provideIdleService({ timeout: 60000 })], // 1 minute
})
export class AppComponent {
  private idle = inject(IdleService);

  constructor() {
    this.idle.start();

    effect(() => {
      if (this.idle.isIdle()) {
        console.log('User is idle!');
      }
    });
  }
}
```

You can also provide it at the application level in `app.config.ts`:

```typescript
export const appConfig: ApplicationConfig = {
  providers: [
    provideIdleService({ timeout: 300000 }), // 5 minutes
  ],
};
```

---

## Runtime Configuration

Use `configure()` to override settings at runtime. If monitoring is already running, it will automatically restart with the new options:

```typescript
// Change timeout dynamically
this.idle.configure({ timeout: 120000 }); // 2 minutes

// Change monitored events
this.idle.configure({ 
  events: ['mousemove', 'keydown', 'click'] 
});

// Change both
this.idle.configure({ 
  timeout: 30000,
  events: ['mousemove', 'touchstart'] 
});
```

---

## API

### Methods

| Method | Description |
|--------|-------------|
| `configure(options)` | Set timeout and events to monitor |
| `start()` | Start monitoring for activity |
| `stop()` | Stop monitoring |
| `reset()` | Reset idle timer |

### Properties

| Property | Type | Description |
|----------|------|-------------|
| `isIdle` | `Signal<boolean>` | Current idle state |
| `isIdle$` | `Observable<boolean>` | Observable stream |

### Monitored Events

By default, the service listens for the following DOM events to detect user activity:

- `mousemove` - Mouse movement
- `keydown` - Keyboard input
- `touchstart` - Touch interactions
- `scroll` - Page scrolling
- `click` - Mouse clicks

You can customize these via the `events` option in `IdleOptions`.

### IdleOptions

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `timeout` | `number` | `300000` (5min) | Idle timeout in ms |
| `events` | `string[]` | `['mousemove', 'keydown', 'touchstart', 'scroll', 'click']` | Events to monitor |

## Demo

{{ NgDocActions.demo("IdleDemoComponent", { container: true }) }}

## Jwt

**URL**: https://love1024.github.io/ngx-oneforall/services/jwt
**Import**: `ngx-oneforall/services/jwt`

Decode, validate, and extract claims from JSON Web Tokens (JWTs) with a configurable token source.

## Features

- **Decode JWT** — Extract header and payload without verification
- **Claim Access** — Get individual claims with type safety
- **Validity Checks** — Check expiration, not-yet-valid, and overall validity
- **Configurable Token Source** — Provide custom `tokenGetter` function
- **Error Handling** — Clear errors for missing, malformed, or invalid tokens

---

## Installation

```typescript
import { JwtService, provideJwtService } from 'ngx-oneforall/services/jwt';
```

---

## Basic Usage

```typescript
import { Component, inject } from '@angular/core';
import { JwtService, provideJwtService } from 'ngx-oneforall/services/jwt';

@Component({
  selector: 'app-demo',
  template: `<p>Token valid: </p>`,
  providers: [
    provideJwtService({
      tokenGetter: () => localStorage.getItem('access_token') ?? '',
    }),
  ],
})
export class DemoComponent {
  private jwt = inject(JwtService);
  isValid = this.jwt.isValid();
}
```

---

## API Reference

| Method | Returns | Description |
|--------|---------|-------------|
| `decodeHeader<T>(token?)` | `T` | Decode and return JWT header |
| `decodeBody<T>(token?)` | `T` | Decode and return JWT payload |
| `getClaim<T>(claim, token?)` | `T \| undefined` | Get specific claim value |
| `getExpirationDate(token?)` | `Date \| null` | Get `exp` claim as Date |
| `getIssuedAtDate(token?)` | `Date \| null` | Get `iat` claim as Date |
| `isExpired(token?, offset?)` | `boolean` | Check if token is expired |
| `isNotYetValid(token?)` | `boolean` | Check `nbf` claim |
| `isValid(token?, offset?)` | `boolean` | Check structure + expiration + nbf |
| `getTimeUntilExpiration(token?)` | `number \| null` | Milliseconds until expiration |
| `getToken()` | `string` | Get token from tokenGetter |
| `getConfig()` | `JwtOptions` | Get service configuration |

---

## Configuration

```typescript
interface JwtOptions {
  tokenGetter?: () => string | null;
  authScheme?: string;           // Default: 'Bearer '
  headerName?: string;           // Default: 'Authorization'
  errorOnNoToken?: boolean;
  skipAddingIfExpired?: boolean;
  allowedDomains?: (string | RegExp)[];
  skipUrls?: (string | RegExp)[];
  refreshTokenHandler?: RefreshTokenHandler;
}
```

---

## Auth Guard Example

```typescript
export const authGuard: CanActivateFn = () => {
  const jwt = inject(JwtService);
  const router = inject(Router);

  if (jwt.isExpired()) {
    router.navigateByUrl('/login');
    return false;
  }
  return true;
};
```

---

## SSR Considerations

> **Note**
> The service itself is SSR-safe, but your `tokenGetter` must handle server environments:

```typescript
// ✅ SSR-safe tokenGetter
provideJwtService({
  tokenGetter: () => {
    if (typeof localStorage === 'undefined') return '';
    return localStorage.getItem('token') ?? '';
  }
})

// ✅ Better: Use cookies (available on server)
provideJwtService({
  tokenGetter: () => cookieService.get('access_token')
})
```

---

## Error Handling

The service throws descriptive errors:

| Error | Cause |
|-------|-------|
| `'Token is missing.'` | Empty token from `tokenGetter` |
| `'Token is not a valid JWT.'` | Token doesn't have 3 dot-separated parts |
| `'Failed to decode JWT header.'` | Invalid base64 or JSON in header |
| `'Failed to decode JWT payload.'` | Invalid base64 or JSON in payload |

---

## Security Notes

> **Warning**
> This service **does not verify JWT signatures**. It only decodes and validates structure/claims. Signature verification should be done server-side.

## Local Storage

**URL**: https://love1024.github.io/ngx-oneforall/services/local-storage-service
**Import**: `ngx-oneforall/services/local-storage-service`

Type-safe wrapper around browser localStorage with transformers for different data types.

## Features

- **Type-Safe** — Use transformers for JSON, Number, Boolean, Date, Base64
- **Key Prefix** — Optional prefix for all keys  
- **SSR Safe** — Falls back to in-memory storage on server
- **New Methods** — `keys()` and `getAll()` for bulk operations

---

## Installation

```typescript
import { 
  LocalStorageService, 
  provideLocalStorage, 
  StorageTransformers 
} from 'ngx-oneforall/services/storage';
```

---

## Basic Usage

```typescript
import { Component, inject } from '@angular/core';
import { LocalStorageService, provideLocalStorage } from 'ngx-oneforall/services/storage';

@Component({
  selector: 'app-demo',
  template: `<p>Name: </p>`,
  providers: [provideLocalStorage()],
})
export class DemoComponent {
  private storage = inject(LocalStorageService);
  name = this.storage.get('user_name') ?? 'Guest';

  saveName(value: string) {
    this.storage.set('user_name', value);
  }
}
```

---

## API Reference

| Method | Returns | Description |
|--------|---------|-------------|
| `get<T>(key, transformer?)` | `T \| undefined` | Get value by key |
| `set<T>(key, value, transformer?)` | `void` | Set value by key |
| `has(key)` | `boolean` | Check if key exists |
| `remove(key)` | `void` | Remove key |
| `clear()` | `void` | Clear all keys (prefix-aware) |
| `keys()` | `string[]` | Get all keys |
| `getAll<T>(transformer?)` | `Map<string, T>` | Get all key-value pairs |
| `length()` | `number` | Number of stored items |

---

## Transformers

```typescript
import { StorageTransformers } from 'ngx-oneforall/services/storage';

// Store as JSON
storage.set('user', { name: 'John' }, StorageTransformers.JSON);
const user = storage.get('user', StorageTransformers.JSON);

// Store as Number
storage.set('count', 42, StorageTransformers.NUMBER);
const count = storage.get('count', StorageTransformers.NUMBER);
```

| Transformer | Type | Description |
|-------------|------|-------------|
| `STRING` | `string` | Default, no transformation |
| `JSON` | `object` | JSON.stringify/parse |
| `NUMBER` | `number` | Number conversion |
| `BOOLEAN` | `boolean` | Boolean conversion |
| `DATE` | `Date` | ISO date string |
| `BASE64` | `Uint8Array` | Binary data |

---

## Key Prefix

```typescript
// All keys prefixed with 'app_'
providers: [provideLocalStorage('app_')]
```

---

## SSR Behavior

On server-side rendering, `LocalStorageService` automatically uses in-memory storage (no errors).

---

## Live Demo

## Logger

**URL**: https://love1024.github.io/ngx-oneforall/services/logger-service
**Import**: `ngx-oneforall/services/logger-service`

Configurable logging service with support for disabling and custom logger implementations.

## Features

- **4 Log Levels** — `log`, `error`, `warn`, `debug`
- **Disable Logging** — Completely disable in production
- **Custom Logger** — Replace console with your own implementation (e.g., send to server)
- **Type-Safe** — Full TypeScript support

---

## Installation

```typescript
import { 
  LoggerService, 
  provideLoggerService,
  DISABLE_LOGGER,
  CUSTOM_LOGGER,
  CustomLogger
} from 'ngx-oneforall/services/logger';
```

---

## Basic Usage

```typescript
import { Component, inject } from '@angular/core';
import { LoggerService, provideLoggerService } from 'ngx-oneforall/services/logger';

@Component({
  selector: 'app-demo',
  template: `<button (click)="onClick()">Log</button>`,
  providers: [provideLoggerService()],
})
export class DemoComponent {
  private logger = inject(LoggerService);

  onClick() {
    this.logger.log('User clicked button');
    this.logger.debug('Debug info', { timestamp: Date.now() });
    this.logger.warn('This is a warning');
    this.logger.error('Something went wrong!');
  }
}
```

---

## API Reference

| Method | Description |
|--------|-------------|
| `log(...args)` | Standard console.log |
| `error(...args)` | console.error |
| `warn(...args)` | console.warn |
| `debug(...args)` | console.debug |

---

## Disable Logging

Disable all logging (useful for production):

```typescript
import { DISABLE_LOGGER, provideLoggerService } from 'ngx-oneforall/services/logger';

bootstrapApplication(AppComponent, {
  providers: [
    provideLoggerService(),
    { provide: DISABLE_LOGGER, useValue: true },
  ],
});
```

When disabled, all log methods become no-ops.

---

## Custom Logger

Replace the default console with your own implementation:

```typescript
import { CUSTOM_LOGGER, CustomLogger, provideLoggerService } from 'ngx-oneforall/services/logger';

const serverLogger: CustomLogger = {
  log: (...args) => sendToServer('log', args),
  error: (...args) => sendToServer('error', args),
  warn: (...args) => sendToServer('warn', args),
  debug: (...args) => {}, // Suppress debug in production
};

bootstrapApplication(AppComponent, {
  providers: [
    provideLoggerService(),
    { provide: CUSTOM_LOGGER, useValue: serverLogger },
  ],
});
```

---

## CustomLogger Interface

```typescript
interface CustomLogger {
  log: (...args: unknown[]) => void;
  error: (...args: unknown[]) => void;
  warn: (...args: unknown[]) => void;
  debug: (...args: unknown[]) => void;
}
```

---

## Priority

1. If `DISABLE_LOGGER` is `true` → All methods are no-ops
2. If `CUSTOM_LOGGER` is provided → Uses custom implementation
3. Otherwise → Uses `console` methods

---

## Live Demo



### Custom Logger Demo

## Network Status

**URL**: https://love1024.github.io/ngx-oneforall/services/network-status
**Import**: `ngx-oneforall/services/network-status`

Monitor browser network connectivity with reactive signals and observables.

## Features

- **Signal-Based** — `isOnlineSignal` for reactive templates
- **Observable-Based** — `isOnline$` for RxJS workflows  
- **Boolean Getters** — `isOnline` and `isOffline`
- **SSR Safe** — Safe checks for window availability
- **Auto Updates** — Listens to browser online/offline events

---

## Installation

```typescript
import { 
  NetworkStatusService, 
  provideNetworkStatusService 
} from 'ngx-oneforall/services/network-status';
```

---

## Basic Usage

```typescript
import { Component, inject } from '@angular/core';
import { NetworkStatusService, provideNetworkStatusService } from 'ngx-oneforall/services/network-status';

@Component({
  selector: 'app-demo',
  template: `
    @if (network.isOnlineSignal()) {
      <span class="online">● Online</span>
    } @else {
      <span class="offline">● Offline</span>
    }
  `,
  providers: [provideNetworkStatusService()],
})
export class DemoComponent {
  network = inject(NetworkStatusService);
}
```

---

## API Reference

| Property | Type | Description |
|----------|------|-------------|
| `isOnline` | `boolean` | Current online status |
| `isOffline` | `boolean` | Current offline status |
| `isOnlineSignal` | `Signal<boolean>` | Reactive signal for templates |
| `isOnline$` | `Observable<boolean>` | Observable stream of status |

---

## Using with RxJS

```typescript
@Component({...})
export class DemoComponent {
  private network = inject(NetworkStatusService);

  constructor() {
    this.network.isOnline$.pipe(
      filter(online => !online),
      takeUntilDestroyed()
    ).subscribe(() => {
      this.showOfflineToast();
    });
  }
}
```

---

## SSR Behavior

On server-side rendering:
- `isOnline` returns `true` (optimistic default)
- No event listeners are attached \

---

## Live Demo

## Session Storage

**URL**: https://love1024.github.io/ngx-oneforall/services/session-storage-service
**Import**: `ngx-oneforall/services/session-storage-service`

Type-safe wrapper around browser sessionStorage with transformers for different data types.

## Features

- **Type-Safe** — Use transformers for JSON, Number, Boolean, Date, Base64
- **Key Prefix** — Optional prefix for all keys  
- **SSR Safe** — Falls back to in-memory storage on server
- **New Methods** — `keys()` and `getAll()` for bulk operations
- **Session Scoped** — Data cleared when browser tab closes

---

## Installation

```typescript
import { 
  SessionStorageService, 
  provideSessionStorage, 
  StorageTransformers 
} from 'ngx-oneforall/services/storage';
```

---

## Basic Usage

```typescript
import { Component, inject } from '@angular/core';
import { SessionStorageService, provideSessionStorage } from 'ngx-oneforall/services/storage';

@Component({
  selector: 'app-demo',
  template: `<p>Token: </p>`,
  providers: [provideSessionStorage()],
})
export class DemoComponent {
  private storage = inject(SessionStorageService);
  token = this.storage.get('auth_token') ?? '';

  saveToken(value: string) {
    this.storage.set('auth_token', value);
  }
}
```

---

## API Reference

| Method | Returns | Description |
|--------|---------|-------------|
| `get<T>(key, transformer?)` | `T \| undefined` | Get value by key |
| `set<T>(key, value, transformer?)` | `void` | Set value by key |
| `has(key)` | `boolean` | Check if key exists |
| `remove(key)` | `void` | Remove key |
| `clear()` | `void` | Clear all keys (prefix-aware) |
| `keys()` | `string[]` | Get all keys |
| `getAll<T>(transformer?)` | `Map<string, T>` | Get all key-value pairs |
| `length()` | `number` | Number of stored items |

---

## Transformers

```typescript
import { StorageTransformers } from 'ngx-oneforall/services/storage';

// Store as JSON
storage.set('session', { id: '123' }, StorageTransformers.JSON);
const session = storage.get('session', StorageTransformers.JSON);

// Store as Boolean
storage.set('isLoggedIn', true, StorageTransformers.BOOLEAN);
const isLoggedIn = storage.get('isLoggedIn', StorageTransformers.BOOLEAN);
```

| Transformer | Type | Description |
|-------------|------|-------------|
| `STRING` | `string` | Default, no transformation |
| `JSON` | `object` | JSON.stringify/parse |
| `NUMBER` | `number` | Number conversion |
| `BOOLEAN` | `boolean` | Boolean conversion |
| `DATE` | `Date` | ISO date string |
| `BASE64` | `Uint8Array` | Binary data |

---

## Key Prefix

```typescript
// All keys prefixed with 'session_'
providers: [provideSessionStorage('session_')]
```

---

## SSR Behavior

On server-side rendering, `SessionStorageService` automatically uses in-memory storage (no errors).

---

## Local vs Session Storage

| Feature | LocalStorage | SessionStorage |
|---------|--------------|----------------|
| Persistence | Until cleared | Until tab closes |
| Shared | All tabs | Single tab only |
| Use case | User preferences | Auth tokens, temp data |

---

## Live Demo

## Shortcut

**URL**: https://love1024.github.io/ngx-oneforall/services/shortcut
**Import**: `ngx-oneforall/services/shortcut`

Observable-based keyboard shortcut handling with cross-platform modifier support.

## Features

- **Observable API** — Returns `Observable<KeyboardEvent>` for shortcuts
- **Cross-Platform** — `cmd`/`meta` maps to `ctrl` on non-Apple platforms
- **Multiple Shortcuts** — Comma-separated: `"ctrl.s, meta.s"`
- **Scoped/Global** — Listen on specific elements or globally
- **SSR Safe** — No listeners attached on server

---

## Installation

```typescript
import { 
  ShortcutService, 
  provideShortcutService,
  ShortcutOptions 
} from 'ngx-oneforall/services/shortcut';
```

---

## Basic Usage

```typescript
import { Component, inject } from '@angular/core';
import { ShortcutService, provideShortcutService } from 'ngx-oneforall/services/shortcut';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';

@Component({
  selector: 'app-demo',
  template: `<p>Press Ctrl+S to save</p>`,
  providers: [provideShortcutService()],
})
export class DemoComponent {
  private shortcuts = inject(ShortcutService);

  constructor() {
    this.shortcuts.observe({ key: 'ctrl.s', isGlobal: true })
      .pipe(takeUntilDestroyed())
      .subscribe(() => this.save());
  }

  save() {
    console.log('Saved!');
  }
}
```

---

## API Reference

### `observe(options: ShortcutOptions)`

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `key` | `string` | **required** | Shortcut pattern(s), e.g. `"ctrl.s"` |
| `isGlobal` | `boolean` | `false` | Listen on window |
| `element` | `HTMLElement` | — | Target element (if not global) |
| `preventDefault` | `boolean` | `true` | Prevent browser default |

---

## Shortcut Patterns

```typescript
// Single shortcut
{ key: 'ctrl.s' }

// Multiple shortcuts (either triggers)
{ key: 'ctrl.s, meta.s' }

// Multiple modifiers
{ key: 'ctrl.shift.n' }

// Arrow keys and special keys
{ key: 'ctrl.arrowup' }
{ key: 'escape' }
{ key: 'enter' }
```

---

## Supported Keys

### Modifiers
`ctrl`, `shift`, `alt`, `meta` (cmd), `control`

### Special Keys
`enter`, `escape` (esc), `space`, `tab`, `backspace`, `delete`

### Arrow Keys
`arrowup` (up), `arrowdown` (down), `arrowleft` (left), `arrowright` (right)

### Punctuation
`period` (.), `comma` (,), `slash` (/), `minus` (-), `equal` (=)

---

## Cross-Platform Shortcuts

```typescript
// Works on both Mac (Cmd+S) and Windows/Linux (Ctrl+S)
{ key: 'ctrl.s, meta.s' }

// On non-Apple platforms, 'cmd' auto-maps to 'ctrl'
{ key: 'cmd.s' } // → ctrl.s on Windows
```

---

## Element-Scoped Shortcuts

```typescript
@ViewChild('editor') editor!: ElementRef;

ngAfterViewInit() {
  this.shortcuts.observe({
    key: 'ctrl.enter',
    element: this.editor.nativeElement,
    isGlobal: false,
  }).subscribe(() => this.submit());
}
```

---

## Live Demo

---

# Signals

## Breakpoint Matcher

**URL**: https://love1024.github.io/ngx-oneforall/signals/breakpoint-matcher
**Import**: `ngx-oneforall/signals/breakpoint-matcher`

`breakpointMatcher` creates a reactive signal that tracks viewport size against media queries. It simplifies responsive design by providing real-time breakpoint matching with Angular signals.

## Usage

Use `breakpointMatcher` to reactively adapt your UI based on viewport size without manual event listeners.

{{ NgDocActions.demo("BreakpointMatcherSignalDemoComponent", { container: true }) }}

### Single Breakpoint

```typescript
import { breakpointMatcher } from 'ngx-oneforall/signals/breakpoint-matcher';
import { BREAKPOINT } from 'ngx-oneforall/constants';

@Component({ ... })
export class ResponsiveComponent {
    // True when viewport matches 'md' breakpoint
    isMedium = breakpointMatcher(BREAKPOINT.MD);
    
    // Or use a custom media query
    isMobile = breakpointMatcher('(max-width: 600px)');
}
```

### Multiple Breakpoints

For checking multiple breakpoints at once, use `breakpointMatcherMultiple`:

{{ NgDocActions.demo("BreakpointMatcherMultipleSignalDemoComponent", { container: true }) }}

```typescript
import { breakpointMatcherMultiple } from 'ngx-oneforall/signals/breakpoint-matcher';
import { BREAKPOINT } from 'ngx-oneforall/constants';

@Component({ ... })
export class LayoutComponent {
    breakpoints = breakpointMatcherMultiple([
        BREAKPOINT.XS, 
        BREAKPOINT.SM_ONLY
    ]);
    
    // Access results
    // breakpoints().some  - true if at least one matches
    // breakpoints().all   - true if all match
    // breakpoints().breakpoints[BREAKPOINT.XS]  - individual status
}
```

## API

### breakpointMatcher

`breakpointMatcher(query: string | BREAKPOINT): Signal<boolean>`

| Parameter | Type | Description |
|-----------|------|-------------|
| `query` | `string \| BREAKPOINT` | Media query or predefined breakpoint |

Returns a signal that is `true` when the viewport matches.

### breakpointMatcherMultiple

`breakpointMatcherMultiple(queries: (string | BREAKPOINT)[]): Signal<BreakpointResult>`

| Property | Type | Description |
|----------|------|-------------|
| `some` | `boolean` | True if at least one breakpoint matches |
| `all` | `boolean` | True if all breakpoints match |
| `breakpoints` | `Record<string, boolean>` | Individual match status |

## Predefined Breakpoints

The `ngx-oneforall/constants` package provides standard breakpoints:

## When to Use

✅ **Good use cases:**
- Responsive navigation menus
- Conditional component loading
- Layout switching (grid/list)
- Touch vs mouse interactions

❌ **Avoid when:**
- CSS media queries are sufficient
- You only need container queries

## Debounced

**URL**: https://love1024.github.io/ngx-oneforall/signals/debounced-signal
**Import**: `ngx-oneforall/signals/debounced-signal`

`debouncedSignal` creates a read-only signal that delays updates until the source signal stops changing for a specified duration. Ideal for search inputs, form validation, and window resize handling.

## Usage

Use `debouncedSignal` to wait for rapid changes to settle before reacting.

{{ NgDocActions.demo("DebouncedSignalDemoComponent", { container: true }) }}

### Basic Example

```typescript
import { signal } from '@angular/core';
import { debouncedSignal } from 'ngx-oneforall/signals/debounced-signal';

@Component({ ... })
export class SearchComponent {
    searchTerm = signal('');
    
    // Updates only after user stops typing for 500ms
    debouncedTerm = debouncedSignal(this.searchTerm, 500);
    
    constructor() {
        effect(() => {
            const term = this.debouncedTerm();
            if (term) {
                this.performSearch(term);
            }
        });
    }
}
```

## API

`debouncedSignal<T>(source: Signal<T>, delay: number): Signal<T>`

| Parameter | Type | Description |
|-----------|------|-------------|
| `source` | `Signal<T>` | The source signal to debounce |
| `delay` | `number` | Delay in milliseconds |

Returns a read-only signal that reflects the source value after the delay.

> **Note**
> The internal timer is automatically cleaned up when the injection context is destroyed.

## When to Use

✅ **Good use cases:**
- Search input with API calls
- Form validation on change
- Window resize handlers
- Auto-save functionality

❌ **Avoid when:**
- You need immediate response
- You want rate limiting instead (use `throttledSignal`)

## Deep Computed

**URL**: https://love1024.github.io/ngx-oneforall/signals/deep-computed
**Import**: `ngx-oneforall/signals/deep-computed`

`deepComputed` creates a computed signal that allows readonly nested property access using proxy syntax. This is useful for accessing deeply nested properties as signals, rather than repeatedly calling the root signal.

> **Note**
> If you need writable nested properties, use `stateSignal` instead.

## Usage

Use `deepComputed` when you have complex nested objects in signals and want individual property access.

{{ NgDocActions.demo("DeepComputedDemoComponent", { container: true }) }}



### Basic Example

```typescript
import { signal, computed } from '@angular/core';
import { deepComputed } from 'ngx-oneforall/signals/deep-computed';

@Component({ ... })
export class MyComponent {
    user = signal({ profile: { name: 'John', age: 30 } });
    userComputed = deepComputed(() => this.user());

    // Access nested properties as signals
    name = this.userComputed.profile.name; // Signal<string>
    
    ngOnInit() {
        console.log(this.name()); // 'John'
    }
}
```



### Reactive Updates

```typescript
user = signal({ profile: { name: 'John' } });
deep = deepComputed(() => this.user());

console.log(deep.profile.name()); // 'John'

user.set({ profile: { name: 'Jane' } });
console.log(deep.profile.name()); // 'Jane' - automatically reactive
```

## API

`deepComputed<T>(factory: () => T): DeepComputed<T>`

- **factory**: A computation function that returns an object.

Returns a proxy-wrapped computed signal that provides nested signal access.

### How It Works

- **Signal Access**: Each nested property returns a computed signal
- **Proxy Recursion**: Nested objects are recursively wrapped in `deepComputed`
- **Caching**: Signals and proxies are cached for performance
- **Type Safety**: Full TypeScript support with proper type inference

> **Note**
> `deepComputed` only works with plain objects. Arrays and built-in types (Date, Map, etc.) are returned as regular signals.

## When to Use

✅ **Good use cases:**
- Complex nested state from stores
- Deeply nested API responses
- Avoiding repetitive signal calls

❌ **Avoid when:**
- State is flat or simple
- Performance is critical (adds proxy overhead)
- Working with arrays or collections

## DOM Event

**URL**: https://love1024.github.io/ngx-oneforall/signals/event-signal
**Import**: `ngx-oneforall/signals/event-signal`

`eventSignal` creates a reactive signal from DOM events. It automatically handles event listener setup, cleanup, and Angular zone execution.

## Usage

Use `eventSignal` to track DOM events reactively. Must be called within an injection context.

{{ NgDocActions.demo("EventSignalDemoComponent", { container: true }) }}

### Basic Example

```typescript
import { eventSignal } from 'ngx-oneforall/signals/event-signal';

@Component({ ... })
export class ClickTrackerComponent {
    // Track clicks on the document
    clickEvent = eventSignal(document, 'click');
    
    constructor() {
        effect(() => {
            const event = this.clickEvent();
            if (event) {
                console.log('Clicked at:', event.clientX, event.clientY);
            }
        });
    }
}
```

### With Element Reference

```typescript
@Component({
    template: `<button #btn>Click me</button>`
})
export class MyComponent {
    private elementRef = inject(ElementRef);
    
    // Listen on host element
    hostClick = eventSignal(this.elementRef.nativeElement, 'click');
}
```

## API

`eventSignal<T = Event>(target: EventTarget, eventName: string, options?: AddEventListenerOptions): WritableSignal<T | null>`

| Parameter | Type | Description |
|-----------|------|-------------|
| `target` | `EventTarget` | DOM element or EventTarget to listen on |
| `eventName` | `string` | Event name (e.g., 'click', 'mousemove') |
| `options` | `AddEventListenerOptions` | Optional listener options |

Returns a writable signal that holds the latest event, or `null` before first event.

> **Note**
> Must be called in an injection context (constructor, field initializer). For elements not available at construction (like `viewChild`), use `runInInjectionContext` in `ngAfterViewInit`.

## When to Use

✅ **Good use cases:**
- Mouse/touch tracking
- Keyboard shortcuts
- Scroll position monitoring
- Custom drag-and-drop

❌ **Avoid when:**
- Using Angular's built-in event binding is sufficient
- You need complex event composition (use RxJS `fromEvent`)

## Interval

**URL**: https://love1024.github.io/ngx-oneforall/signals/interval-signal
**Import**: `ngx-oneforall/signals/interval-signal`

`intervalSignal` creates a controllable interval timer that updates a signal. It runs the timer outside Angular's zone for performance and only triggers change detection when updating the signal.

## Usage

Use `intervalSignal` to create timers, countdowns, or periodic updates with start/stop control.

{{ NgDocActions.demo("IntervalSignalDemoComponent", { container: true }) }}

### Basic Example

```typescript
import { intervalSignal } from 'ngx-oneforall/signals/interval-signal';

@Component({ ... })
export class TimerComponent {
    // Ticks every 1000ms (1 second)
    timer = intervalSignal(1000);
    
    constructor() {
        effect(() => {
            console.log('Tick:', this.timer.value());
        });
    }
    
    start() {
        this.timer.start();
    }
    
    stop() {
        this.timer.stop();
    }
}
```

## API

`intervalSignal(ms: number): IntervalController`

| Parameter | Type | Description |
|-----------|------|-------------|
| `ms` | `number` | Interval duration in milliseconds |

### IntervalController

The returned object provides:

| Property/Method | Type | Description |
|-----------------|------|-------------|
| `value` | `WritableSignal<number>` | Current tick count (starts at 0) |
| `running` | `WritableSignal<boolean>` | Whether the timer is active |
| `start()` | `() => void` | Starts the interval |
| `stop()` | `() => void` | Stops the interval |

> **Note**
> The interval automatically cleans up when the injection context is destroyed.

## When to Use

✅ **Good use cases:**
- Countdown timers
- Auto-refresh data polling
- Animation frame timing
- Session timeout warnings

❌ **Avoid when:**
- You need one-time delays (use `setTimeout`)
- You're polling an API (use RxJS `timer` with HTTP)

## Route Params

**URL**: https://love1024.github.io/ngx-oneforall/signals/route-param-signal
**Import**: `ngx-oneforall/signals/route-param-signal`

`routeParamSignal` creates a reactive signal that tracks route parameters. It automatically updates when the URL's route parameters change, eliminating manual subscriptions.

## Usage

Use `routeParamSignal` to reactively access route parameters in signal-based components.

### Single Parameter

```typescript
import { routeParamSignal } from 'ngx-oneforall/signals/route-param-signal';

@Component({ ... })
export class ProductDetailComponent {
    // Tracks the 'id' route parameter
    productId = routeParamSignal('id');
    
    constructor() {
        effect(() => {
            const id = this.productId();
            if (id) {
                this.loadProduct(id);
            }
        });
    }
}
```

### All Parameters

```typescript
import { routeParamsMapSignal } from 'ngx-oneforall/signals/route-param-signal';

@Component({ ... })
export class RouteInfoComponent {
    // Get all route params as ParamMap
    params = routeParamsMapSignal();
    
    constructor() {
        effect(() => {
            const map = this.params();
            console.log('Category:', map.get('category'));
            console.log('ID:', map.get('id'));
        });
    }
}
```

## API

### routeParamSignal

`routeParamSignal(paramName: string): Signal<string | null>`

| Parameter | Type | Description |
|-----------|------|-------------|
| `paramName` | `string` | Name of the route parameter |

Returns a signal with the current parameter value, or `null` if not present.

### routeParamsMapSignal

`routeParamsMapSignal(): Signal<ParamMap>`

Returns a signal containing the full `ParamMap` of route parameters.

> **Note**
> Both signals automatically update when navigation changes the route parameters.

## When to Use

✅ **Good use cases:**
- Detail pages (`/products/:id`)
- Nested routes with parameters
- Dynamic route segments
- Master-detail layouts

❌ **Avoid when:**
- You need query parameters (use `routeQueryParamSignal`)
- You need route data, not params (use `ActivatedRoute.data`)

## Route Query

**URL**: https://love1024.github.io/ngx-oneforall/signals/route-query-param-signal
**Import**: `ngx-oneforall/signals/route-query-param-signal`

`routeQueryParamSignal` creates a reactive signal that tracks URL query parameters. It automatically updates when query strings change, eliminating manual subscriptions.

## Usage

Use `routeQueryParamSignal` to reactively access query parameters in signal-based components.

### Single Query Parameter

```typescript
import { routeQueryParamSignal } from 'ngx-oneforall/signals/route-query-param-signal';

@Component({ ... })
export class SearchComponent {
    // Tracks the 'q' query parameter (?q=value)
    searchTerm = routeQueryParamSignal('q');
    
    constructor() {
        effect(() => {
            const term = this.searchTerm();
            if (term) {
                this.performSearch(term);
            }
        });
    }
}
```

### All Query Parameters

```typescript
import { routeQueryParamsMapSignal } from 'ngx-oneforall/signals/route-query-param-signal';

@Component({ ... })
export class FilterComponent {
    // Get all query params as ParamMap
    queryParams = routeQueryParamsMapSignal();
    
    constructor() {
        effect(() => {
            const map = this.queryParams();
            console.log('Sort:', map.get('sort'));
            console.log('Page:', map.get('page'));
        });
    }
}
```

## API

### routeQueryParamSignal

`routeQueryParamSignal(paramName: string): Signal<string | null>`

| Parameter | Type | Description |
|-----------|------|-------------|
| `paramName` | `string` | Name of the query parameter |

Returns a signal with the current parameter value, or `null` if not present.

### routeQueryParamsMapSignal

`routeQueryParamsMapSignal(): Signal<ParamMap>`

Returns a signal containing the full `ParamMap` of query parameters.

> **Note**
> Both signals automatically update when navigation changes the query string.

## When to Use

✅ **Good use cases:**
- Search pages (`?q=angular`)
- Filter and sort controls
- Pagination (`?page=2`)
- Shareable URLs with state

❌ **Avoid when:**
- You need route path parameters (use `routeParamSignal`)
- You need fragment data (use `ActivatedRoute.fragment`)

## Router Event

**URL**: https://love1024.github.io/ngx-oneforall/signals/router-event-signal
**Import**: `ngx-oneforall/signals/router-event-signal`

`routerEventSignal` creates a reactive signal that tracks Angular Router events. It provides easy access to the current event and computed helpers for common navigation states.

## Usage

Use `routerEventSignal` to react to navigation changes with Angular signals.

{{ NgDocActions.demo("RouterEventSignalDemoComponent", { container: true }) }}

### Basic Example

```typescript
import { routerEventSignal } from 'ngx-oneforall/signals/router-event-signal';

@Component({ ... })
export class NavigationComponent {
    router = routerEventSignal();
    
    constructor() {
        effect(() => {
            if (this.router.isNavigationEnd()) {
                console.log('Navigation complete!');
                this.trackPageView();
            }
        });
    }
}
```

### Loading Indicator

```typescript
@Component({
    template: `
        @if (router.isNavigationStart()) {
            <div class="loading">Loading...</div>
        }
    `
})
export class AppComponent {
    router = routerEventSignal();
}
```

## API

`routerEventSignal(): RouterEventState`

### RouterEventState

The returned object provides:

| Property | Type | Description |
|----------|------|-------------|
| `event` | `Signal<RouterEvent \| null>` | Most recent router event |
| `isNavigationStart` | `Signal<boolean>` | True during navigation start |
| `isNavigationEnd` | `Signal<boolean>` | True after navigation completes |

> **Note**
> The subscription is automatically cleaned up when the injection context is destroyed.

## When to Use

✅ **Good use cases:**
- Loading indicators during navigation
- Analytics/page view tracking
- Navigation guards with signals
- Scroll position restoration

❌ **Avoid when:**
- You need detailed route data (use `ActivatedRoute`)
- You need to prevent navigation (use route guards)

## State

**URL**: https://love1024.github.io/ngx-oneforall/signals/state-signal
**Import**: `ngx-oneforall/signals/state-signal`

`stateSignal` creates a deep writable signal that allows nested property access and updates using proxy syntax. Updates to nested properties automatically propagate (bubble) up to the root signal.

## Usage

Use `stateSignal` when you have complex nested objects and want ergonomic property access with the ability to update nested values directly.

{{ NgDocActions.demo("StateSignalDemoComponent", { container: true }) }}

### Basic Example

```typescript
import { stateSignal } from 'ngx-oneforall/signals/state-signal';

@Component({ ... })
export class MyComponent {
    state = stateSignal({ 
        user: { 
            name: 'John', 
            age: 30 
        } 
    });

    // Access nested properties as signals
    name = this.state.user.name; // StateSignal<string>
    
    ngOnInit() {
        console.log(this.name()); // 'John'
        
        // Update nested property - automatically bubbles to root
        this.name.set('Jane');
        console.log(this.state().user.name); // 'Jane'
    }
}
```

### Nested Updates with Bubbling

```typescript
state = stateSignal({ 
    profile: { 
        address: { 
            city: 'New York' 
        } 
    } 
});

// Direct nested update
state.profile.address.city.set('Los Angeles');

// Root signal is updated automatically
console.log(state().profile.address.city); // 'Los Angeles'

// Use update() for derived values
state.profile.address.city.update(city => city.toUpperCase());
```

### Using with Existing Signal

```typescript
import { signal } from '@angular/core';
import { stateSignal } from 'ngx-oneforall/signals/state-signal';

// Wrap an existing signal
const source = signal({ count: 0 });
const state = stateSignal(source);

state.count.set(10);
console.log(source().count); // 10 - source is updated
```

## API

`stateSignal<T>(initialValue: T | WritableSignal<T>, onUpdate?: (value: T) => void): StateSignal<T>`

- **initialValue**: An object or an existing `WritableSignal` to wrap
- **onUpdate**: Optional callback invoked when the signal is updated (used internally for bubbling)

Returns a proxy-wrapped writable signal that provides nested signal access with update propagation.

### Available Methods

- `set(value)` - Replace the value at any level
- `update(fn)` - Update based on current value
- `asReadonly()` - Get a readonly version of the signal
- `()` - Read the current value

### How It Works

- **Nested Signals**: Each nested property returns a writable `StateSignal`
- **Bubbling**: Updates at any level propagate to the root with new object references
- **Caching**: Nested signals are cached for performance
- **Type Safety**: Full TypeScript support with proper type inference

> **Note**
> `stateSignal` only recurses into plain objects. Arrays are treated as single signals and not recursed into element-by-element.

## When to Use

✅ **Good use cases:**
- Complex nested form state
- Deeply nested configuration objects
- When you need to update specific nested properties without manually spreading

❌ **Avoid when:**
- State is flat or simple
- Working primarily with arrays (use regular signals)
- Performance is critical (adds proxy overhead)

## Comparison with deepComputed

| Feature | `stateSignal` | `deepComputed` |
|---------|---------------|----------------|
| **Writable** | ✅ Yes | ❌ Read-only |
| **Bubbling** | ✅ Updates propagate to root | N/A |
| **Use case** | Mutable nested state | Derived nested state |

## Storage

**URL**: https://love1024.github.io/ngx-oneforall/signals/storage-signal
**Import**: `ngx-oneforall/signals/storage-signal`

`storageSignal` creates a reactive signal that automatically syncs with browser storage (`localStorage` or `sessionStorage`). Changes to the signal persist to storage, and the signal can optionally sync across browser tabs.

## Usage

Use `storageSignal` to persist state across page refreshes or share state between tabs.

{{ NgDocActions.demo("StorageSignalDemoComponent", { container: true }) }}

### Basic Example

```typescript
import { storageSignal } from 'ngx-oneforall/signals/storage-signal';

@Component({ ... })
export class MyComponent {
    // Persists to localStorage under key 'counter'
    counter = storageSignal<number>('counter', 0);

    increment() {
        this.counter.update(c => c + 1);
        // Value is automatically saved to localStorage
    }
}
```

> **Note**
> The signal must be created within an injection context (e.g., constructor, field initializer) or you must provide an `injector` in options.

### Using Session Storage

```typescript
// Use sessionStorage instead of localStorage
const token = storageSignal<string>('session-token', '', { 
    storage: sessionStorage 
});
```

### Cross-Tab Synchronization

```typescript
// Changes in one tab will reflect in all open tabs
const cart = storageSignal<string[]>('cart', [], { 
    crossTabSync: true 
});
```

### Custom Serialization

```typescript
interface User {
    id: number;
    name: string;
}

const user = storageSignal<User>('current-user', { id: 0, name: '' }, {
    serializer: (value) => JSON.stringify(value),
    deserializer: (data) => JSON.parse(data)
});
```

## API

`storageSignal<T>(key: string, defaultValue: T, options?: StorageSignalOptions<T>): WritableSignal<T>`

### Parameters

| Parameter | Type | Description |
|-----------|------|-------------|
| `key` | `string` | The storage key to use |
| `defaultValue` | `T` | Initial value if nothing in storage |
| `options` | `StorageSignalOptions<T>` | Optional configuration |

### Options

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `storage` | `Storage` | `localStorage` | Storage backend (`localStorage`, `sessionStorage`, or custom) |
| `serializer` | `(v: T) => string` | `JSON.stringify` | Function to serialize value to string |
| `deserializer` | `(data: string) => T` | `JSON.parse` | Function to deserialize string to value |
| `crossTabSync` | `boolean` | `false` | Sync changes across browser tabs |
| `injector` | `Injector` | Current injector | Angular injector for use outside injection context |

## When to Use

✅ **Good use cases:**
- User preferences (theme, language)
- Form draft auto-save
- Shopping cart persistence
- Authentication tokens

❌ **Avoid when:**
- Storing sensitive data (use secure cookies instead)
- Large datasets (storage limits apply)
- Data that changes very frequently (storage writes are synchronous)

## Throttled

**URL**: https://love1024.github.io/ngx-oneforall/signals/throttled-signal
**Import**: `ngx-oneforall/signals/throttled-signal`

`throttledSignal` creates a read-only signal that limits how often the source signal's updates are emitted. It ensures updates occur at most once per specified interval, regardless of how frequently the source changes.

## Usage

Use `throttledSignal` when you need to limit the rate of updates from high-frequency events like scroll, mousemove, or resize.

{{ NgDocActions.demo("ThrottledSignalDemoComponent", { container: true }) }}

### Basic Example

```typescript
import { signal } from '@angular/core';
import { throttledSignal } from 'ngx-oneforall/signals/throttled-signal';

@Component({ ... })
export class MouseTrackerComponent {
    coords = signal('0, 0');
    
    // Updates at most once every 100ms
    throttledCoords = throttledSignal(this.coords, 100);
    
    onMouseMove(event: MouseEvent) {
        this.coords.set(`${event.clientX}, ${event.clientY}`);
    }
}
```

## API

`throttledSignal<T>(source: Signal<T>, delay: number): Signal<T>`

| Parameter | Type | Description |
|-----------|------|-------------|
| `source` | `Signal<T>` | The source signal to throttle |
| `delay` | `number` | Minimum interval between updates (ms) |

Returns a read-only signal that updates at most once per `delay` interval.

> **Note**
> The internal timer is automatically cleaned up when the injection context is destroyed.

## Debounce vs Throttle

| Behavior | `debouncedSignal` | `throttledSignal` |
|----------|-------------------|-------------------|
| **When it emits** | After source stops changing | At regular intervals |
| **Use case** | Wait for input to settle | Rate-limit frequent updates |
| **Example** | Search input | Scroll position tracking |

## When to Use

✅ **Good use cases:**
- Scroll event handling
- Mouse movement tracking
- Window resize handlers
- Progress updates

❌ **Avoid when:**
- You need to wait for input to settle (use `debouncedSignal`)
- You need immediate response to every change

## WebSocket

**URL**: https://love1024.github.io/ngx-oneforall/signals/websocket-signal
**Import**: `ngx-oneforall/signals/websocket-signal`

`webSocketSignal` creates a reactive interface for WebSocket connections. It manages the connection lifecycle and provides signals for messages, status, and errors.

## Usage

Use `webSocketSignal` to integrate real-time WebSocket features with Angular's signal-based reactivity.

{{ NgDocActions.demo("WebSocketSignalDemoComponent", { container: true }) }}

### Basic Example

```typescript
import { webSocketSignal } from 'ngx-oneforall/signals/websocket-signal';

@Component({ ... })
export class ChatComponent {
    socket = webSocketSignal<string>('wss://echo.websocket.org');
    
    constructor() {
        effect(() => {
            const msg = this.socket.messages();
            if (msg) {
                console.log('Received:', msg);
            }
        });
    }
    
    send(text: string) {
        if (this.socket.status() === 'open') {
            this.socket.send(text);
        }
    }
}
```

### Handling Connection Status

```typescript
@Component({
    template: `
        <div [class]="socket.status()">
            Status:  socket.status().toUpperCase() ' }}
        </div>
        @if (socket.status() === 'open') {
            <button (click)="socket.close()">Disconnect</button>
        }
    `
})
export class StatusComponent {
    socket = webSocketSignal('wss://example.com');
}
```

## API

`webSocketSignal<T>(url: string): WebSocketState<T>`

| Parameter | Type | Description |
|-----------|------|-------------|
| `url` | `string` | WebSocket server URL |

### WebSocketState

The returned object provides:

| Property/Method | Type | Description |
|-----------------|------|-------------|
| `messages` | `Signal<T \| null>` | Latest received message |
| `error` | `Signal<Event \| null>` | Latest error event |
| `status` | `Signal<'connecting' \| 'open' \| 'closed' \| 'error'>` | Connection status |
| `send(msg)` | `(msg: T) => void` | Send a message |
| `close()` | `() => void` | Close the connection |

> **Note**
> The connection is automatically closed when the injection context is destroyed.

## When to Use

✅ **Good use cases:**
- Real-time chat applications
- Live notifications
- Stock/crypto price feeds
- Collaborative editing

❌ **Avoid when:**
- You need request/response patterns (use HTTP)
- Server doesn't support WebSocket
- You need complex reconnection logic (use dedicated libraries)

---

# Types

## Callable

**URL**: https://love1024.github.io/ngx-oneforall/types/callable
**Import**: `ngx-oneforall/types/callable`

`Callable` is a utility type that represents a function signature. It allows you to specify the argument types and return type.

## Usage

Use `Callable` when you need to define a generic function type with specific arguments or return type, essentially a shorthand for `{ (...args: Args): Return }`.

```typescript
import { Callable } from 'ngx-oneforall/types';

// Function taking any args and returning any
const fn: Callable = () => {};

// Function taking string and number, returning boolean
const specificFn: Callable<[string, number], boolean> = (str, num) => {
    return true;
};
```

## API

`Callable<Args extends any[] = any[], Return = any>`

- **Args**: Tuple definition of argument types. Default is `any[]`.
- **Return**: Return type. Default is `any`.

## DeepPartial

**URL**: https://love1024.github.io/ngx-oneforall/types/deep-partial
**Import**: `ngx-oneforall/types/deep-partial`

`DeepPartial` is a utility type that recursively makes all properties of a type and its nested objects optional. This is similar to `Partial<T>`, but applies deeply.

## Usage

Use `DeepPartial` when you need to construct an object that might only have some deep properties defined, for example when mocking data in tests or applying partial updates.

```typescript
import { DeepPartial } from 'ngx-oneforall/types';

interface Config {
    theme: {
        color: string;
        darkMode: boolean;
    };
    api: {
        endpoint: string;
        retries: number;
    };
}

// Valid
const partialConfig: DeepPartial<Config> = {
    theme: {
        darkMode: true
    }
    // api can be undefined
    // theme.color can be undefined
};
```

## API

`DeepPartial<T>`

- **T**: The source type to make deeply partial.

## IsArrowFunction

**URL**: https://love1024.github.io/ngx-oneforall/types/is-arrow-function
**Import**: `ngx-oneforall/types/is-arrow-function`

`IsArrowFunction` is a utility type that determines if a given type is an arrow function. It returns `true` if the type is an arrow function (doesn't have a `this` context), and `false` otherwise.

## Usage

Use `IsArrowFunction` when you need to conditionally type based on whether a function is an arrow function or a standard function.

```typescript
import { IsArrowFunction } from 'ngx-oneforall/types';

const arrow = () => {};
function standard() {}

type CheckArrow = IsArrowFunction<typeof arrow>; // true
type CheckStandard = IsArrowFunction<typeof standard>; // false
```

## API

`IsArrowFunction<T>`

- **T**: The type to check.

Returns `true` or `false`.

## KeysOfType

**URL**: https://love1024.github.io/ngx-oneforall/types/keys-of-type
**Import**: `ngx-oneforall/types/keys-of-type`

`KeysOfType` is a utility type that extracts the keys from a type `T` where the value extends the type `U`.

## Usage

Use `KeysOfType` to filter keys of an object based on their value types.

```typescript
import { KeysOfType } from 'ngx-oneforall/types';

interface User {
    id: number;
    name: string;
    isActive: boolean;
    age: number;
}

// Result: 'id' | 'age'
type NumberKeys = KeysOfType<User, number>;

// Result: 'name'
type StringKeys = KeysOfType<User, string>;
```

## API

`KeysOfType<T, U>`

- **T**: The source type to extract keys from.
- **U**: The type that the value must extend.

## OmitByValue

**URL**: https://love1024.github.io/ngx-oneforall/types/omit-by-value
**Import**: `ngx-oneforall/types/omit-by-value`

`OmitByValue` is a utility type that constructs a new type by omitting properties from type `T` where the value extends type `V`. It combines `Omit` and `KeysOfType`.

## Usage

Use `OmitByValue` when you want to exclude properties of a specific type from an object.

```typescript
import { OmitByValue } from 'ngx-oneforall/types';

interface User {
    id: number;
    name: string;
    isActive: boolean;
    age: number;
    description: string;
}

// Result: { name: string; isActive: boolean; description: string; }
type NonNumericUserProps = OmitByValue<User, number>;
```

## API

`OmitByValue<T, V>`

- **T**: The source type.
- **V**: The type to omit values by.

## PartialOnly

**URL**: https://love1024.github.io/ngx-oneforall/types/partial-only
**Import**: `ngx-oneforall/types/partial-only`

`PartialOnly` is a utility type that picks specified properties from a type and makes them optional, while removing all other properties. It effectively combines `Pick` and `Partial`.

## Usage

Use `PartialOnly` when you need a subset of a type where the selected properties should be optional.

```typescript
import { PartialOnly } from 'ngx-oneforall/types';

interface User {
    id: number;
    name: string;
    email: string;
    age: number;
}

// Result: { name?: string; email?: string; }
type UserUpdate = PartialOnly<User, 'name' | 'email'>;
```

## API

`PartialOnly<T, K extends keyof T>`

- **T**: The source type.
- **K**: The keys to pick and make partial.

## PickByValue

**URL**: https://love1024.github.io/ngx-oneforall/types/pick-by-value
**Import**: `ngx-oneforall/types/pick-by-value`

`PickByValue` is a utility type that constructs a new type by picking properties from type `T` where the value extends type `V`. It combines `Pick` and `KeysOfType`.

## Usage

Use `PickByValue` when you want to create a new object type containing only properties of a specific type.

```typescript
import { PickByValue } from 'ngx-oneforall/types';

interface User {
    id: number;
    name: string;
    isActive: boolean;
    age: number;
}

// Result: { id: number; age: number; }
type NumericUserProps = PickByValue<User, number>;
```

## API

`PickByValue<T, V>`

- **T**: The source type.
- **V**: The type to filter values by.

## RequiredOnly

**URL**: https://love1024.github.io/ngx-oneforall/types/required-only
**Import**: `ngx-oneforall/types/required-only`

`RequiredOnly` is a utility type that makes specified properties of a type required, while removing all other properties. It effectively combines `Pick` and `Required`.

## Usage

Use `RequiredOnly` when you need a subset of a type where the selected properties must be present and non-optional.

```typescript
import { RequiredOnly } from 'ngx-oneforall/types';

interface User {
    id: number;
    name?: string;
    email?: string;
    age?: number;
}

// Result: { name: string; email: string; }
type UserContact = RequiredOnly<User, 'name' | 'email'>;
```

## API

`RequiredOnly<T, K extends keyof T>`

- **T**: The source type.
- **K**: The keys to pick and make required.

## Simple Changes

**URL**: https://love1024.github.io/ngx-oneforall/types/simple-changes
**Import**: `ngx-oneforall/types/simple-changes`

A type-safe version of Angular's `SimpleChanges` that provides proper typing for `ngOnChanges` lifecycle hook. Eliminates the need for type assertions when accessing change properties.

## Usage

```typescript
import { SimpleChangesTyped } from 'ngx-oneforall/types';
```

## API

```typescript
type SimpleChangesTyped<T> = {
  [P in keyof T]?: ComponentChange<T, P>;
};

interface ComponentChange<T, P extends keyof T> {
  previousValue: T[P];
  currentValue: T[P];
  firstChange: boolean;
  isFirstChange(): boolean;
}
```

| Property | Type | Description |
|----------|------|-------------|
| `previousValue` | `T[P]` | The previous value before the change |
| `currentValue` | `T[P]` | The current value after the change |
| `firstChange` | `boolean` | True if this is the initial binding |
| `isFirstChange()` | `() => boolean` | Returns true if this is the initial binding |

> **Note**
> All properties are optional (`?`) since not all inputs change on every `ngOnChanges` cycle.

## Example

```typescript
@Component({
  selector: 'app-user',
  template: `<p></p>`
})
export class UserComponent implements OnChanges {
  @Input() name!: string;
  @Input() age!: number;

  ngOnChanges(changes: SimpleChangesTyped<UserComponent>) {
    if (changes.name) {
      // TypeScript knows these are strings
      console.log('Name:', changes.name.previousValue, '→', changes.name.currentValue);
    }

    if (changes.age?.firstChange) {
      // TypeScript knows this is a number
      console.log('Initial age:', changes.age.currentValue);
    }
  }
}
```

## Comparison

```typescript
// ❌ Without SimpleChangesTyped
ngOnChanges(changes: SimpleChanges) {
  if (changes['name']) {
    const prev = changes['name'].previousValue as string; // Manual cast
  }
}

// ✅ With SimpleChangesTyped
ngOnChanges(changes: SimpleChangesTyped<MyComponent>) {
  if (changes.name) {
    const prev = changes.name.previousValue; // Automatically typed as string
  }
}
```

## Use Cases

- **Type-safe change detection**: Access previous/current values without casting
- **Autocomplete support**: IDE provides suggestions for available properties
- **Refactoring safety**: Rename refactoring works correctly across components
- **Better error detection**: Catch typos at compile time

---

# Utils

## Base64 URL

**URL**: https://love1024.github.io/ngx-oneforall/utils/base64-url
**Import**: `ngx-oneforall/utils/base64-url`

URL-safe Base64 encoding utilities for safely transmitting data in URLs, query parameters, and tokens.

## Usage

Import the functions from the base64 utility:

```typescript
import { base64UrlEncode, base64UrlDecode } from 'ngx-oneforall/utils/base64';
```

### Encoding

```typescript
const encoded = base64UrlEncode('Hello, 世界!');
// Result: "SGVsbG8sIOS4lueVjCE"
```

### Decoding

```typescript
const decoded = base64UrlDecode('SGVsbG8sIOS4lueVjCE');
// Result: "Hello, 世界!"
```

## API

| Function | Description |
|----------|-------------|
| `base64UrlEncode(value: string)` | Encodes a UTF-8 string to URL-safe base64 (RFC 4648) |
| `base64UrlDecode(value: string)` | Decodes a URL-safe base64 string to UTF-8 |

> **Note**
> These utilities correctly handle multi-byte Unicode characters (e.g., Chinese, emoji) using `TextEncoder`/`TextDecoder`.

## Use Cases

- **JWT Tokens**: Encode/decode JWT payload segments
- **Query Parameters**: Safely embed binary data in URLs
- **OAuth State**: Encode state parameters for OAuth flows
- **Data URIs**: Create URL-safe data identifiers

## Live Demo

## Download Link

**URL**: https://love1024.github.io/ngx-oneforall/utils/download-link
**Import**: `ngx-oneforall/utils/download-link`

`downloadLink` is a utility function that programmatically triggers a file download by creating a temporary anchor element.

## Usage

Use `downloadLink` when you have a file URL (or Blob URL) and want to initiate a download action, for example from a button click or after an API response.

{{ NgDocActions.demo("DownloadLinkDemoComponent", { container: true }) }}

### Example

```typescript
import { downloadLink } from 'ngx-oneforall/utils/download-link';

// Download a remote file
downloadLink('https://example.com/report.pdf', 'report.pdf');

// Download a generated blob
const blob = new Blob(['content'], { type: 'text/plain' });
const url = URL.createObjectURL(blob);
downloadLink(url, 'note.txt');
```

## API

`downloadLink(url: string, fileName: string = 'download'): void`

- **url**: The URL of the file to download. Can be a remote URL or a blob URL.
- **fileName**: The name to suggest for the downloaded file. Defaults to `'download'`.

> **Note**
> For cross-origin URLs, the `download` attribute might be ignored by browsers for security reasons, resulting in navigation instead of download unless the server sends appropriate `Content-Disposition` headers.

## File to Base64

**URL**: https://love1024.github.io/ngx-oneforall/utils/file-base64
**Import**: `ngx-oneforall/utils/file-base64`

Converts a `File` object to a base64-encoded data URL string asynchronously.

## Usage

```typescript
import { fileToBase64 } from 'ngx-oneforall/utils/base64';
```

### Basic Example

```typescript
async onFileChange(event: Event) {
  const input = event.target as HTMLInputElement;
  const file = input.files?.[0];
  
  if (file) {
    const dataUrl = await fileToBase64(file);
    // dataUrl: "data:image/png;base64,iVBORw0KGgo..."
  }
}
```

### Angular Template

```html
<input type="file" (change)="onFileChange($event)">
<img [src]="imagePreview" *ngIf="imagePreview">
```

## API

`fileToBase64(file: File): Promise<string>`

| Parameter | Type | Description |
|-----------|------|-------------|
| `file` | `File` | The file object from an input element |
| **Returns** | `Promise<string>` | Data URL (e.g., `data:image/png;base64,...`) |

## Use Cases

- **Image Previews**: Display uploaded images before submission
- **File Uploads**: Convert files to base64 for API transmission
- **Avatar Editors**: Create inline image previews
- **Form Data**: Store file content in JSON payloads

## Live Demo

## Find Type

**URL**: https://love1024.github.io/ngx-oneforall/utils/find-type
**Import**: `ngx-oneforall/utils/find-type`

Comprehensive type detection utility that returns a `Types` enum value for any JavaScript value. Supports all primitives, collections, typed arrays, and iterators.

## Usage

```typescript
import { findType } from 'ngx-oneforall/utils/find-type';
import { Types } from 'ngx-oneforall/constants';

findType(42);           // Types.Number
findType('hello');      // Types.String
findType(BigInt(123));  // Types.BigInt
findType(new Map());    // Types.Map
```

## Supported Types

| Category | Types |
|----------|-------|
| **Primitives** | `Null`, `Undefined`, `Boolean`, `String`, `Number`, `BigInt`, `Symbol` |
| **Functions** | `Function`, `GeneratorFunction` |
| **Collections** | `Array`, `Map`, `WeakMap`, `Set`, `WeakSet` |
| **Typed Arrays** | `Int8Array`, `Uint8Array`, `Uint8ClampedArray`, `Int16Array`, `Uint16Array`, `Int32Array`, `Uint32Array`, `Float32Array`, `Float64Array` |
| **Iterators** | `MapIterator`, `SetIterator`, `StringIterator`, `ArrayIterator`, `GeneratorObject` |
| **Fallback** | `Object` (for plain objects and class instances) |

## Quick Examples

```typescript
findType(null);             // Types.Null
findType(undefined);        // Types.Undefined
findType(true);             // Types.Boolean
findType(42);               // Types.Number
findType(BigInt(999));      // Types.BigInt
findType(Symbol('id'));     // Types.Symbol
findType(() => {});         // Types.Function
findType(function* () {});  // Types.GeneratorFunction
findType([1, 2, 3]);        // Types.Array
findType(new Map());        // Types.Map
findType(new Set());        // Types.Set
findType(new Int8Array());  // Types.Int8Array
findType({});               // Types.Object
```

## Type Guard Helpers

All type checking functions are also exported as type guards:

```typescript
import { isString, isNumber, isBigInt, isArray, isMap } from 'ngx-oneforall/utils/find-type';

const value: unknown = getData();

if (isString(value)) {
  console.log(value.toUpperCase()); // TypeScript knows it's string
}

if (isArray(value)) {
  console.log(value.length); // TypeScript knows it's unknown[]
}
```

## Available Type Guards

| Function | Type Guard |
|----------|------------|
| `isNull(v)` | `v is null` |
| `isUndefined(v)` | `v is undefined` |
| `isBoolean(v)` | `v is boolean` |
| `isString(v)` | `v is string` |
| `isNumber(v)` | `v is number` |
| `isBigInt(v)` | `v is bigint` |
| `isSymbol(v)` | `v is symbol` |
| `isFunction(v)` | `v is (...args) => any` |
| `isArray(v)` | `v is unknown[]` |
| `isMap(v)` | `v is Map<unknown, unknown>` |
| `isSet(v)` | `v is Set<unknown>` |
| `isDate(v)` | `v is Date` |
| `isRegexp(v)` | `v is RegExp` |
| `isError(v)` | `v is Error` |

> **Note**
> Detection order is optimized for common types first. More specific types (like `GeneratorFunction`) are checked before general ones (like `Function`).

## Use Cases

- **API validation**: Check data types from external sources
- **Dynamic rendering**: Render different UI based on value type
- **Form handling**: Validate input values before processing
- **Debugging**: Log precise runtime types

## Hash

**URL**: https://love1024.github.io/ngx-oneforall/utils/hash
**Import**: `ngx-oneforall/utils/hash`

Fast, non-cryptographic string hashing utilities for generating numeric hash codes.

## Usage

```typescript
import { hashCode, hashCodeWithSalt } from 'ngx-oneforall/utils/hash';
```

### Basic Hashing

```typescript
const hash = hashCode('hello');
// hash: -1794106052
```

### Salted Hashing

```typescript
const hash = hashCodeWithSalt('hello', 'my-secret-salt');
// Different result than hashCode('hello')
```

## API

| Function | Description |
|----------|-------------|
| `hashCode(str: string)` | Generates a 32-bit signed integer hash |
| `hashCodeWithSalt(str: string, salt: string)` | Generates a salted hash using the salt's hash as seed |

## Algorithm

Uses the DJB2-like algorithm, equivalent to Java's `String.hashCode()`:

```
hash = ((hash << 5) - hash + charCode) | 0
     = (hash * 31 + charCode) | 0
```

The `| 0` ensures 32-bit signed integer truncation.

## Use Cases

- **Cache Keys**: Generate numeric keys for caching mechanisms
- **Hash Tables**: Distribute objects across buckets
- **Quick Comparison**: Fast string equality pre-check
- **Partitioning**: Consistent assignment to shards/partitions

> **Note**
> This is a non-cryptographic hash. Do not use for passwords, security tokens, or any security-sensitive application. Use `crypto` or `bcrypt` instead.

## Example: Cache Key Generation

```typescript
function getCacheKey(userId: string, resource: string): number {
  return hashCode(`${userId}:${resource}`);
}

const key = getCacheKey('user-123', 'profile');
cache.set(key, data);
```

## Example: Consistent Partitioning

```typescript
function getPartition(key: string, partitionCount: number): number {
  return Math.abs(hashCode(key)) % partitionCount;
}

const partition = getPartition('order-456', 8);
// Always returns same partition for same key
```

## Host Platform

**URL**: https://love1024.github.io/ngx-oneforall/utils/host-platform
**Import**: `ngx-oneforall/utils/host-platform`

---
keyword: HostPlatformPage
---

Detects the host platform/operating system based on the user agent string. SSR-safe with modern iPadOS 13+ detection.

## Usage

```typescript
import { getHostPlatform } from 'ngx-oneforall/utils/host-platform';
import { HostPlatform } from 'ngx-oneforall/constants';

const platform = getHostPlatform();

if (platform === HostPlatform.IOS) {
  // iOS-specific logic (includes iPad)
}
```

## API

`getHostPlatform(): HostPlatform`

Returns one of the following enum values:

| Value | Description |
|-------|-------------|
| `HostPlatform.MAC` | macOS desktop |
| `HostPlatform.IOS` | iPhone, iPad, iPod (including iPadOS 13+) |
| `HostPlatform.WINDOWS` | Windows desktop |
| `HostPlatform.WINDOWS_PHONE` | Windows Phone |
| `HostPlatform.ANDROID` | Android devices |
| `HostPlatform.LINUX` | Linux distributions |
| `HostPlatform.UNKNOWN` | SSR or unrecognized platform |

> **Note**
> iPadOS 13+ reports as "Macintosh" in the user agent. This utility uses touch detection to correctly identify iPads.

## Use Cases

- **Platform-specific UI**: Show different layouts for mobile vs desktop
- **Feature detection**: Enable/disable features based on platform
- **Analytics**: Track user platform distribution
- **Download links**: Show appropriate app store links

## Example: Conditional Rendering

```typescript
@Component({...})
export class AppComponent {
  platform = getHostPlatform();
  
  get isMobile(): boolean {
    return [HostPlatform.IOS, HostPlatform.ANDROID].includes(this.platform);
  }
}
```

## Demo

{{ NgDocActions.demo("HostPlatformDemoComponent", {container: true}) }}

## Is Key Defined

**URL**: https://love1024.github.io/ngx-oneforall/utils/is-key-defined
**Import**: `ngx-oneforall/utils/is-key-defined`

Type guard utility that checks if an object has a defined (non-undefined) value for a given key, with TypeScript type narrowing.

## Usage

```typescript
import { isKeyDefined } from 'ngx-oneforall/utils/is-key-defined';

const user = { name: 'John', age: undefined };

if (isKeyDefined(user, 'name')) {
  console.log(user.name.toUpperCase()); // TypeScript knows name is defined
}
```

## API

```typescript
isKeyDefined<T extends object, K extends keyof T>(
  obj: T,
  key: K,
  ownPropertyOnly?: boolean
): obj is T & Record<K, NonNullable<T[K]>>
```

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `obj` | `T` | - | The object to check |
| `key` | `keyof T` | - | The key to check for |
| `ownPropertyOnly` | `boolean` | `true` | Only check own properties, exclude inherited |

> **Note**
> This function acts as a type guard—when it returns `true`, TypeScript narrows the type to guarantee the key's value is non-nullable.

## Use Cases

- **Safe property access**: Prevent "cannot read property of undefined" errors
- **Form validation**: Verify required fields are present
- **API responses**: Safely access dynamic object properties
- **Type narrowing**: Let TypeScript know a property is defined

## Example: Including Inherited Properties

```typescript
class Base { inherited = 'value'; }
class Child extends Base { own = 'child'; }

const child = new Child();

// Default: only own properties
isKeyDefined(child, 'own');       // true
isKeyDefined(child, 'inherited'); // false (it's inherited)

// Include inherited
isKeyDefined(child, 'inherited', false); // true
```

## Example: Guarding Object Access

```typescript
interface Config {
  apiUrl?: string;
  timeout?: number;
}

function initializeApi(config: Config) {
  if (isKeyDefined(config, 'apiUrl')) {
    // TypeScript knows config.apiUrl is string, not undefined
    fetch(config.apiUrl);
  }
}
```

## Is Number

**URL**: https://love1024.github.io/ngx-oneforall/utils/is-number
**Import**: `ngx-oneforall/utils/is-number`

Type guard utilities for validating numeric values. Provides robust checking for number primitives, numeric strings, and Number objects.

## Usage

```typescript
import { isNumberValue, isNumberString, isNumeric, isNumberObject } from 'ngx-oneforall/utils/is-number';
```

## API

| Function | Returns `true` for | Returns `false` for |
|----------|-------------------|---------------------|
| `isNumberValue(value)` | Finite number primitives | `NaN`, `Infinity`, strings, objects |
| `isNumberString(value)` | Strings parseable as numbers | Empty strings, whitespace, non-numeric |
| `isNumberObject(value)` | `new Number()` objects | Primitives, other objects |
| `isNumeric(value)` | Numbers OR numeric strings | Everything else |

## Quick Examples

```typescript
// isNumberValue - finite number primitives only
isNumberValue(42);        // true
isNumberValue(3.14);      // true
isNumberValue(NaN);       // false
isNumberValue(Infinity);  // false
isNumberValue('42');      // false

// isNumberString - valid numeric strings
isNumberString('42');     // true
isNumberString('3.14');   // true
isNumberString('');       // false
isNumberString('   ');    // false
isNumberString('abc');    // false

// isNumeric - either number or numeric string
isNumeric(42);            // true
isNumeric('42');          // true
isNumeric(null);          // false
```

## Edge Cases

| Input | `isNumberValue` | `isNumberString` | `isNumeric` |
|-------|-----------------|------------------|-------------|
| `42` | ✅ | ❌ | ✅ |
| `'42'` | ❌ | ✅ | ✅ |
| `NaN` | ❌ | ❌ | ❌ |
| `Infinity` | ❌ | ❌ | ❌ |
| `''` | ❌ | ❌ | ❌ |
| `'   '` | ❌ | ❌ | ❌ |
| `null` | ❌ | ❌ | ❌ |
| `new Number(42)` | ❌ | ❌ | ❌ |

> **Note**
> `isNumeric` does NOT include `Number` objects. Use `isNumberObject` separately if needed.

## Use Cases

- **Form Validation**: Validate numeric input fields
- **Type Narrowing**: Let TypeScript know a value is a number
- **API Responses**: Safely handle mixed `number | string` data
- **Data Parsing**: Check before `parseInt` or `parseFloat`

## Example: Safe Numeric Parsing

```typescript
function parseValue(input: unknown): number | null {
  if (isNumberValue(input)) {
    return input; // Already a number
  }
  if (isNumberString(input)) {
    return parseFloat(input);
  }
  return null;
}

parseValue(42);     // 42
parseValue('3.14'); // 3.14
parseValue('abc');  // null
```

## Example: Type-Safe Calculation

```typescript
function double(value: unknown): number | null {
  if (isNumeric(value)) {
    const num = typeof value === 'string' ? parseFloat(value) : value;
    return num * 2;
  }
  return null;
}
```

## Is Present

**URL**: https://love1024.github.io/ngx-oneforall/utils/is-present
**Import**: `ngx-oneforall/utils/is-present`

Type guard utility that checks if a value is neither `null` nor `undefined`. Narrows the type to `NonNullable<T>`.

## Usage

```typescript
import { isPresent } from 'ngx-oneforall/utils/is-present';
```

## API

`isPresent<T>(value: T): value is NonNullable<T>`

Returns `true` if value is not `null` and not `undefined`.

| Input | Result |
|-------|--------|
| `'hello'` | ✅ `true` |
| `0` | ✅ `true` |
| `false` | ✅ `true` |
| `''` | ✅ `true` |
| `null` | ❌ `false` |
| `undefined` | ❌ `false` |

> **Note**
> Falsy values like `0`, `false`, and `''` are considered "present" since they are not nullish.

## Example: Type Narrowing

```typescript
const value: string | null | undefined = getValue();

if (isPresent(value)) {
  console.log(value.toUpperCase()); // TypeScript knows value is string
}
```

## Example: Array Filtering

```typescript
const items = [1, null, 2, undefined, 3];
const filtered = items.filter(isPresent);
// filtered: number[] = [1, 2, 3]
```

## Example: Optional Chaining Alternative

```typescript
// Instead of:
if (user?.profile?.name !== undefined && user?.profile?.name !== null) {
  // ...
}

// Use:
if (isPresent(user?.profile?.name)) {
  // TypeScript narrows type correctly
}
```

## Use Cases

- **Array cleanup**: Filter out null/undefined from arrays
- **Type narrowing**: Let TypeScript know a value is defined
- **Form validation**: Check if optional values are present
- **API responses**: Safely access potentially null data

## Is Record

**URL**: https://love1024.github.io/ngx-oneforall/utils/is-record
**Import**: `ngx-oneforall/utils/is-record`

Type guard that checks if a value is a plain object (record) as opposed to built-in types, arrays, or class instances.

## Usage

```typescript
import { isRecord } from 'ngx-oneforall/utils/is-record';
```

## API

`isRecord(value: unknown): value is Record<string, unknown>`

Returns `true` if value is a plain object, `false` otherwise.

## Quick Examples

```typescript
isRecord({});              // true
isRecord({ a: 1, b: 2 });  // true
isRecord(Object.create(null)); // true (null-prototype)

isRecord([1, 2, 3]);       // false (array)
isRecord(new Date());      // false (built-in)
isRecord(new Map());       // false (built-in)
isRecord(new MyClass());   // false (class instance)
isRecord(null);            // false
```

## Truth Table

| Input | Result | Reason |
|-------|--------|--------|
| `{}` | ✅ | Plain object literal |
| `{ a: 1 }` | ✅ | Plain object with properties |
| `Object.create(null)` | ✅ | Null-prototype object |
| `[]` | ❌ | Array |
| `new Date()` | ❌ | Built-in |
| `new Map()` | ❌ | Built-in |
| `new Set()` | ❌ | Built-in |
| `new Error()` | ❌ | Built-in |
| `new MyClass()` | ❌ | Class instance |
| `null` | ❌ | Not an object |
| `undefined` | ❌ | Not an object |

## Detection Strategy

The implementation uses a multi-step approach for accuracy and performance:

1. **Fast path**: Check if prototype is `null` or `Object.prototype`
2. **Built-in exclusion**: Check against known non-record constructors (Date, Map, Set, etc.)
3. **Fallback**: Use `Object.prototype.toString` for edge cases

> **Note**
> This implementation explicitly excludes class instances and all JavaScript built-in types including `ArrayBuffer`, `Blob`, `File`, `URL`, and more.

## Example: Type-Safe Iteration

```typescript
function processData(value: unknown) {
  if (isRecord(value)) {
    // TypeScript knows value is Record<string, unknown>
    Object.entries(value).forEach(([key, val]) => {
      console.log(key, val);
    });
  }
}
```

## Example: Deep Clone Safety

```typescript
function safeClone(obj: unknown): unknown {
  if (!isRecord(obj)) {
    return obj; // Return primitives/built-ins as-is
  }
  
  const result: Record<string, unknown> = {};
  for (const [key, value] of Object.entries(obj)) {
    result[key] = safeClone(value);
  }
  return result;
}
```

## Use Cases

- **Safe object iteration**: Avoid iterating arrays or class instances
- **Serialization**: Validate objects before JSON.stringify
- **API validation**: Check if response is a plain object
- **State management**: Distinguish records from other object types

## Normalize Key

**URL**: https://love1024.github.io/ngx-oneforall/utils/normalize-key
**Import**: `ngx-oneforall/utils/normalize-key`

---
keyword: NormalizeKeyPage
---

The `normalizeKey` utility standardizes keyboard key values across different browsers and platforms. It handles common inconsistencies and maps user-friendly aliases to standard `KeyboardEvent.key` values.

## Usage

Import `normalizeKey` from `ngx-oneforall`:

```typescript
import {normalizeKey} from 'ngx-oneforall/utils/normalize-key';

// Basic usage
const key = normalizeKey('Esc'); // Returns 'escape'
const space = normalizeKey('Space'); // Returns ' '

// Platform-specific normalization
// On Windows/Linux/Android, 'meta' becomes 'control'
const meta = normalizeKey('meta'); 
```

## Transformations

The utility performs the following transformations:

| Input | Output | Description |
|-------|--------|-------------|
| `space` | `' '` | Maps the string 'space' to a literal space character |
| `esc` | `escape` | Standardizes escape key |
| `up` | `arrowup` | Standardizes arrow keys |
| `down` | `arrowdown` | |
| `left` | `arrowleft` | |
| `right` | `arrowright` | |
| `altleft` | `alt` | Standardizes alt key |
| `meta` | `control` | **On non-Apple platforms only** |

## Case Insensitivity

The function is case-insensitive. Inputs like `ESC`, `Esc`, and `esc` will all return `escape`.

## Demo

Type in the input below to see how keys are normalized:

{{ NgDocActions.demo("NormalizeKeyDemoComponent", {container: true}) }}

## Safe Await

**URL**: https://love1024.github.io/ngx-oneforall/utils/safe-await
**Import**: `ngx-oneforall/utils/safe-await`

Go-style error handling for async operations. Returns a tuple `[result, error]` instead of throwing, eliminating try/catch blocks.

## Usage

```typescript
import { safeAwait } from 'ngx-oneforall/utils/safe-await';
```

## API

```typescript
safeAwait<T>(input: Promise<T> | Observable<T>): Promise<[T, null] | [null, Error]>
```

| Input | Success | Failure |
|-------|---------|---------|
| `Promise<T>` | `[result, null]` | `[null, error]` |
| `Observable<T>` | `[lastValue, null]` | `[null, error]` |

> **Note**
> Observables are converted using `lastValueFrom`. Empty Observables (complete without emitting) will return an `EmptyError`.

## Quick Example

```typescript
const [user, error] = await safeAwait(fetchUser(id));

if (error) {
  console.error('Failed:', error.message);
  return;
}

console.log(user.name); // TypeScript knows user is defined
```

## Comparison: Traditional vs safeAwait

```typescript
// ❌ Traditional try/catch
async function getUser(id: string) {
  try {
    const user = await fetchUser(id);
    return { user, error: null };
  } catch (error) {
    return { user: null, error };
  }
}

// ✅ With safeAwait
async function getUser(id: string) {
  const [user, error] = await safeAwait(fetchUser(id));
  return { user, error };
}
```

## Example: HTTP Request

```typescript
async loadData() {
  const [data, error] = await safeAwait(
    this.http.get<User[]>('/api/users')
  );

  if (error) {
    this.errorMessage = 'Failed to load users';
    return;
  }

  this.users = data;
}
```

## Example: Multiple Async Operations

```typescript
async saveOrder() {
  const [inventory, invError] = await safeAwait(checkInventory(this.items));
  if (invError) return this.showError('Inventory check failed');

  const [payment, payError] = await safeAwait(processPayment(this.total));
  if (payError) return this.showError('Payment failed');

  const [order, orderError] = await safeAwait(createOrder(inventory, payment));
  if (orderError) return this.showError('Order creation failed');

  return order;
}
```

## Use Cases

- **HTTP requests**: Handle API errors without try/catch
- **Form submission**: Clean async validation and submission
- **Sequential operations**: Chain multiple async calls with clear error points
- **Observable integration**: Use with Angular's HttpClient seamlessly

## Safe Serialize

**URL**: https://love1024.github.io/ngx-oneforall/utils/safe-serialize
**Import**: `ngx-oneforall/utils/safe-serialize`

Safely serializes any JavaScript value to a JSON string, including non-JSON types like functions, symbols, BigInt, and circular references. Produces deterministic output for caching and memoization.

## Usage

```typescript
import { safeSerialize } from 'ngx-oneforall/utils/safe-serialize';

const key = safeSerialize({ name: 'John', count: BigInt(42) });
// '{"count":"__bigint:42","name":"John"}'
```

## Serialization Format

| Type | Serialized Format |
|------|-------------------|
| Function (named) | `"__fn:functionName"` |
| Function (anonymous) | `"__fn:anonymous\|h:hash"` |
| Symbol | `"__sym:Symbol(description)"` |
| BigInt | `"__bigint:123"` |
| Date | ISO string (built-in JSON behavior) |
| RegExp | `{ __type: 'RegExp', value: '/pattern/flags' }` |
| Error | `{ __type: 'Error', name, message }` |
| Map | `{ __type: 'Map', entries: [[k, v], ...] }` |
| Set | `{ __type: 'Set', values: [...] }` |
| WeakMap | `{ __type: 'WeakMap', note: 'Not iterable' }` |
| WeakSet | `{ __type: 'WeakSet', note: 'Not iterable' }` |
| Class instance | `{ __type: 'ClassName', ...props }` |
| Circular ref | `"__circular__"` |

> **Note**
> Object keys are sorted alphabetically for deterministic output. `{ b: 2, a: 1 }` serializes the same as `{ a: 1, b: 2 }`.

## Quick Examples

```typescript
// Functions
safeSerialize(() => {}); // '"__fn:anonymous|h:-1234567"'

// Symbols and BigInt
safeSerialize([Symbol('id'), BigInt(999)]);
// '["__sym:Symbol(id)","__bigint:999"]'

// Circular references
const obj = { name: 'root' };
obj.self = obj;
safeSerialize(obj); // '{"name":"root","self":"__circular__"}'

// Map and Set
safeSerialize(new Map([['a', 1]]));
// '{"__type":"Map","entries":[["a",1]]}'
```

## Use Cases

- **Memoization keys**: Generate cache keys from any arguments
- **Argument hashing**: Create stable fingerprints for function calls
- **Deep comparison**: Compare complex objects by their serialized form
- **Logging**: Serialize non-JSON values for debugging

## Demo



## Limitations

- **Not reversible**: Cannot deserialize back to original values
- **Lossy for functions/symbols**: Only names/descriptions are preserved
- **WeakMap/WeakSet**: Cannot iterate, serialized with placeholder
- **Same-name collision**: Different functions with same name produce same output

## Unique Component ID

**URL**: https://love1024.github.io/ngx-oneforall/utils/unique-component-id
**Import**: `ngx-oneforall/utils/unique-component-id`

Generates unique ID strings for Angular components. Useful for form elements, ARIA attributes, and dynamically created components.

## Usage

```typescript
import { uniqueComponentId } from 'ngx-oneforall/utils/unique-component-id';
```

## API

`uniqueComponentId(prefix?: string): string`

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `prefix` | `string` | `'id'` | Prefix for the generated ID |

Returns a unique string in the format `{prefix}{counter}`.

```typescript
uniqueComponentId();        // 'id1'
uniqueComponentId();        // 'id2'
uniqueComponentId('btn');   // 'btn1'  (independent counter)
uniqueComponentId('input'); // 'input1' (independent counter)
uniqueComponentId('btn');   // 'btn2'
```

> **Note**
> Each prefix has its own independent counter. `btn1, btn2, input1, input2` instead of a shared global counter.

## Example: Form Label Association

```typescript
@Component({
  selector: 'app-text-input',
  template: `
    <label [attr.for]="inputId"></label>
    <input [id]="inputId" type="text">
  `
})
export class TextInputComponent {
  @Input() label = '';
  inputId = uniqueComponentId('input');
}
```

## Example: ARIA Attributes

```typescript
@Component({
  selector: 'app-dialog',
  template: `
    <div role="dialog" [attr.aria-labelledby]="titleId">
      <h2 [id]="titleId"></h2>
      <ng-content></ng-content>
    </div>
  `
})
export class DialogComponent {
  @Input() title = '';
  titleId = uniqueComponentId('dialog-title');
}
```

## Example: Multiple Instances

```typescript
@Component({
  selector: 'app-accordion-item',
  template: `
    <button [attr.aria-controls]="panelId" (click)="toggle()">
      
    </button>
    <div [id]="panelId" *ngIf="expanded">
      <ng-content></ng-content>
    </div>
  `
})
export class AccordionItemComponent {
  @Input() header = '';
  panelId = uniqueComponentId('panel');
  expanded = false;
  
  toggle() { this.expanded = !this.expanded; }
}
```

## Use Cases

- **Form controls**: Associate labels with inputs via `for`/`id` pairing
- **ARIA attributes**: `aria-labelledby`, `aria-describedby`, `aria-controls`
- **Dynamic components**: Ensure unique IDs across multiple instances
- **Accordion/tabs**: Link triggers to their content panels

---

# Validators

## Credit Card

**URL**: https://love1024.github.io/ngx-oneforall/validators/credit-card
**Import**: `ngx-oneforall/validators/credit-card`

`creditCard` is a validator that checks if the control's value is a valid credit card number using the Luhn algorithm.

It enforces specific PAN lengths (13, 15, 16, 19) and validates 15-digit cards as American Express (must start with 34 or 37). It also handles non-numeric characters (separators) by stripping them before validation.

## Usage

Use `creditCard` to validate credit card inputs.

{{ NgDocActions.demo("CreditCardDemoComponent", { container: true }) }}

### Reactive Forms

```typescript
import { FormControl } from '@angular/forms';
import { creditCard } from 'ngx-oneforall/validators/credit-card';

const control = new FormControl(null, creditCard);
```

### Template-Driven Forms (Directive)

You can use the `creditCard` attribute directive.

```html
<input type="text" [(ngModel)]="value" creditCard>
```

## API

`creditCard: ValidatorFn`

Returns a validation error object with a reason code if validation fails, or `null` if valid.

### Error Codes

| Reason | Description |
|--------|-------------|
| `repeated_digits` | All digits are identical (e.g., `0000000000000000`) |
| `invalid_length` | PAN length is not 13, 15, 16, or 19 digits |
| `invalid_amex_prefix` | 15-digit card doesn't start with 34 or 37 |
| `luhn_failed` | Luhn algorithm checksum failed |

```typescript
// Example error object
{ creditCard: { reason: 'luhn_failed' } }
{ creditCard: { reason: 'invalid_length', actualLength: 12 } }
```

## Date

**URL**: https://love1024.github.io/ngx-oneforall/validators/date
**Import**: `ngx-oneforall/validators/date`

`date` is a validator that ensures the control's value is a valid date. It supports `Date` objects and date strings.

## Usage

Use `date` to validate date inputs.

{{ NgDocActions.demo("DateDemoComponent", { container: true }) }}

### Reactive Forms

```typescript
import { FormControl } from '@angular/forms';
import { date } from 'ngx-oneforall/validators/date';

const control = new FormControl(null, date);
```

### Template-Driven Forms (Directive)

You can use the `date` attribute directive (or `[date]`) with template-driven forms.

```html
<input type="text" [(ngModel)]="value" date>
```

## API

`date: ValidatorFn`

Returns a validation error object with a reason code if validation fails, or `null` if valid.

### Error Codes

| Reason | Description |
|--------|-------------|
| `invalid_date` | Value cannot be parsed as a valid date |
| `unsupported_type` | Value is not a string or Date object |

```typescript
// Example error objects
{ date: { reason: 'invalid_date', actualValue: 'not a date' } }
{ date: { reason: 'unsupported_type', actualValue: true } }
```

## Match Field

**URL**: https://love1024.github.io/ngx-oneforall/validators/match-field
**Import**: `ngx-oneforall/validators/match-field`

`matchFields` is a **group-level validator** that checks if two fields have matching values. Commonly used for "confirm password" or "confirm email" fields.

{{ NgDocActions.demo("MatchFieldDemoComponent", { container: true }) }}

## Usage

Applied at the **FormGroup level** so it detects changes to both fields:

```typescript
import { FormGroup, FormControl, Validators } from '@angular/forms';
import { matchFields } from 'ngx-oneforall/validators/match-field';

const form = new FormGroup({
  password: new FormControl('', Validators.required),
  confirmPassword: new FormControl('', Validators.required)
}, { validators: matchFields('password', 'confirmPassword') });
```

## API

`matchFields(field1: string, field2: string): ValidatorFn`

| Parameter | Type | Description |
|-----------|------|-------------|
| `field1` | `string` | Name of the first control to compare |
| `field2` | `string` | Name of the second control to compare |

### Error Object

When validation fails, returns error on the **FormGroup** (not individual controls):
```typescript
{
  matchFields: {
    field1: 'password',
    field1Value: 'test123',
    field2: 'confirmPassword',
    field2Value: 'different'
  }
}
```

## Template Example

```html
<form [formGroup]="form">
  <input formControlName="password" type="password" placeholder="Password">
  <input formControlName="confirmPassword" type="password" placeholder="Confirm Password">
  
  @if (form.hasError('matchFields')) {
    <span class="error">Passwords do not match</span>
  }
</form>
```

## Template-Driven Forms (Directive)

Use the `matchFields` directive with an array of field names:

```html
<form ngForm [matchFields]="['password', 'confirmPassword']">
  <input type="password" name="password" ngModel />
  <input type="password" name="confirmPassword" ngModel />
  
  @if (form.hasError('matchFields')) {
    <span class="error">Passwords do not match</span>
  }
</form>
```

```typescript
import { MatchFieldsValidator } from 'ngx-oneforall/validators/match-field';

@Component({
  imports: [FormsModule, MatchFieldsValidator],
})
```

## Max Date

**URL**: https://love1024.github.io/ngx-oneforall/validators/max-date
**Import**: `ngx-oneforall/validators/max-date`

`maxDate` is a validator that ensures the control's value is a date less than or equal to a specified maximum date.

## Usage

Use `maxDate` to validate that a date is not after a certain boundary.

>**Note** This validator internally uses the `date` validator to first ensure the inputs are valid date structures.

{{ NgDocActions.demo("MaxDateDemoComponent", { container: true }) }}

### Reactive Forms

```typescript
import { FormControl } from '@angular/forms';
import { maxDate } from 'ngx-oneforall/validators/max-date';

const control = new FormControl(null, maxDate(new Date('2025-12-31')));
// OR with string
const control = new FormControl(null, maxDate('2025-12-31'));
// OR with timestamp
const control = new FormControl(null, maxDate(1735689600000));
```

### Template-Driven Forms (Directive)

You can use the `[maxDate]` directive. It accepts a `Date` object, date string, or numeric timestamp.

```html
<input type="date" [(ngModel)]="value" [maxDate]="maxDateValue">
```

## API

`maxDate(max: Date | string | number): ValidatorFn`

Returns `{ maxDate: { reason: 'date_exceeds_max', requiredDate, actualValue } }` if validation fails, or `null` if valid.

## Min Date

**URL**: https://love1024.github.io/ngx-oneforall/validators/min-date
**Import**: `ngx-oneforall/validators/min-date`

`minDate` is a validator that ensures the control's value is a date greater than or equal to a specified minimum date.

## Usage

Use `minDate` to validate that a date is not before a certain boundary.

>**Note** This validator internally uses the `date` validator to first ensure the inputs are valid date structures.

{{ NgDocActions.demo("MinDateDemoComponent", { container: true }) }}

### Reactive Forms

```typescript
import { FormControl } from '@angular/forms';
import { minDate } from 'ngx-oneforall/validators/min-date';

const control = new FormControl(null, minDate(new Date('2023-01-01')));
// OR with string
const control = new FormControl(null, minDate('2023-01-01'));
// OR with timestamp
const control = new FormControl(null, minDate(1672531200000));
```

### Template-Driven Forms (Directive)

You can use the `[minDate]` directive. It accepts a `Date` object, date string, or numeric timestamp.

```html
<input type="date" [(ngModel)]="value" [minDate]="minDateValue">
```

## API

`minDate(min: Date | string | number): ValidatorFn`

Returns `{ minDate: { reason: 'date_before_min', requiredDate, actualValue } }` if validation fails, or `null` if valid.

## Min Length Trimmed

**URL**: https://love1024.github.io/ngx-oneforall/validators/min-length-trimmed
**Import**: `ngx-oneforall/validators/min-length-trimmed`

`minLengthTrimmed` is a validator that trims whitespace before checking minimum length.

## Usage

Unlike Angular's built-in `Validators.minLength`, this validator trims the value first, preventing whitespace-only strings from passing validation.

{{ NgDocActions.demo("MinLengthTrimmedDemoComponent", { container: true }) }}

### Reactive Forms

```typescript
import { FormControl } from '@angular/forms';
import { minLengthTrimmed } from 'ngx-oneforall/validators/min-length-trimmed';

const control = new FormControl('', minLengthTrimmed(3));

control.setValue('  ab  '); // invalid - trimmed length is 2
control.setValue('abc');    // valid - length is 3
```

### Template-Driven Forms (Directive)

```html
<input type="text" [(ngModel)]="username" [minLengthTrimmed]="3">
```

## API

`minLengthTrimmed(minLength: number): ValidatorFn`

### Error Object

When validation fails, returns:

```typescript
{
  minLengthTrimmed: {
    requiredLength: number,
    actualLength: number
  }
}
```

### Behavior

| Value | Min Length | Result |
|-------|------------|--------|
| `null` / `undefined` | any | Valid |
| `'ab'` | 3 | Invalid (length: 2) |
| `'  ab  '` | 3 | Invalid (trimmed length: 2) |
| `'abc'` | 3 | Valid |
| `'  abc  '` | 3 | Valid (trimmed length: 3) |
| `'   '` | 1 | Invalid (trimmed length: 0) |

## Not Blank

**URL**: https://love1024.github.io/ngx-oneforall/validators/not-blank
**Import**: `ngx-oneforall/validators/not-blank`

`notBlank` is a validator that ensures the control's value is not blank (empty or whitespace-only).

## Usage

Use `notBlank` to validate that input values contain actual content, not just whitespace. Unlike `Validators.required`, this validator fails for strings containing only spaces, tabs, or newlines.

{{ NgDocActions.demo("NotBlankDemoComponent", { container: true }) }}

### Reactive Forms

```typescript
import { FormControl, Validators } from '@angular/forms';
import { notBlank } from 'ngx-oneforall/validators/not-blank';

// Use alone - allows null/undefined
const control = new FormControl(null, notBlank);

// Combine with required for mandatory non-blank field
const requiredControl = new FormControl(null, [Validators.required, notBlank]);
```

### Template-Driven Forms (Directive)

You can use the `[notBlank]` directive with template-driven forms.

```html
<input type="text" [(ngModel)]="name" notBlank>
```

## API

`notBlank: ValidatorFn`

>**Note** Unlike other validators that are functions, `notBlank` is a pre-created `ValidatorFn` constant since it requires no configuration.

### Error Object

When validation fails, returns:

```typescript
{ notBlank: true }
```

### Behavior

| Value | Result |
|-------|--------|
| `null` / `undefined` | Valid (allows composition with `required`) |
| `''` (empty string) | Invalid |
| `'   '` (whitespace only) | Invalid |
| `'\t\n'` (tabs/newlines) | Invalid |
| `'hello'` | Valid |
| `'  hello  '` | Valid |
| Non-string values | Valid |

## Number

**URL**: https://love1024.github.io/ngx-oneforall/validators/number
**Import**: `ngx-oneforall/validators/number`

`number` is a validator that ensures the control's value is a valid finite number or a string representation of a valid finite number.

## Usage

Use `number` to validate that input values are strictly numeric.

{{ NgDocActions.demo("NumberDemoComponent", { container: true }) }}

### Reactive Forms

```typescript
import { FormControl } from '@angular/forms';
import { number } from 'ngx-oneforall/validators/number';

const control = new FormControl(null, number);
```

### Template-Driven Forms (Directive)

You can use the `number` attribute directive (or `[number]`) with template-driven forms.

```html
<input type="text" [(ngModel)]="value" number>
```

## API

`number: ValidatorFn`

Returns a validation error object `{ number: { actualValue } }` if validation fails, or `null` if valid.

## Phone

**URL**: https://love1024.github.io/ngx-oneforall/validators/phone
**Import**: `ngx-oneforall/validators/phone`

`phone` is a validator that checks if the control's value is a valid phone number for a specified country code.

It uses `libphonenumber-js` under the hood to validate phone numbers.

> **Warning**  This validator depends on `libphonenumber-js`, which is 145kb in size. Using this validator will increase your bundle size. Proceed with caution if bundle size is a critical constraint.

## Usage

Use `phone` to validate phone numbers. You must provide a `CountryCode` (Alpha-2 code).

{{ NgDocActions.demo("PhoneDemoComponent", { container: true }) }}

### Reactive Forms

```typescript
import { FormControl } from '@angular/forms';
import { phoneValidator } from 'ngx-oneforall/validators/phone';
import { CountryCode } from 'ngx-oneforall/constants';

const control = new FormControl(null, phoneValidator(CountryCode.UnitedStates));
```

### Template-Driven Forms (Directive)

You can use the `[phone]` attribute directive.

```html
<input type="text" [(ngModel)]="value" [phone]="'US'">
<!-- Or use the CountryCode enum -->
<input type="text" [(ngModel)]="value" [phone]="CountryCode.UnitedStates">
```

## API

`phoneValidator(country: CountryCode): ValidatorFn`

Returns `{ phone: { reason: 'invalid_format', country } }` if validation fails, or `null` if valid.

## Range

**URL**: https://love1024.github.io/ngx-oneforall/validators/range
**Import**: `ngx-oneforall/validators/range`

`range` is a validator that requires the control's value to be within a specified numerical range (inclusive).

## Usage

Use `range` to validate numeric inputs against a minimum and maximum value.

{{ NgDocActions.demo("RangeDemoComponent", { container: true }) }}

### Reactive Forms

```typescript
import { FormControl } from '@angular/forms';
import { range } from 'ngx-oneforall/validators/range';

const control = new FormControl(null, range(5, 10));
```

### Template-Driven Forms (Directive)

You can use the `[range]` directive with template-driven forms. It accepts a tuple `[min, max]`.

```html
<input type="number" [(ngModel)]="value" [range]="[5, 10]">
```

## API

`range(min: number, max: number): ValidatorFn`

- **min**: The minimum required value.
- **max**: The maximum required value.

Returns `{ range: { reason: 'out_of_range', min, max, actualValue } }` if validation fails, or `null` if valid.

## Range Length

**URL**: https://love1024.github.io/ngx-oneforall/validators/range-length
**Import**: `ngx-oneforall/validators/range-length`

`rangeLength` is a validator that requires the length of the value (string, array, or number digits) to be within a specified range.

## Usage

Use `rangeLength` to validate form controls where the input size matters, such as usernames, passwords, or list selections.

{{ NgDocActions.demo("RangeLengthDemoComponent", { container: true }) }}

### Example

```typescript
import { FormControl } from '@angular/forms';
import { rangeLength } from 'ngx-oneforall/validators/range-length';

const control = new FormControl('', rangeLength(5, 10));
```

### Directive Usage

You can also use `[rangeLength]` directive with template-driven forms:

```html
<input [(ngModel)]="value" [rangeLength]="[5, 10]">
```

## API

`rangeLength(min: number, max: number): ValidatorFn`

- **min**: Minimum required length.
- **max**: Maximum allowed length.

Returns `{ rangeLength: { reason: 'length_out_of_range', requiredMinLength, requiredMaxLength, actualLength } }` if validation fails, or `null` if valid.

Throws an error if `min` is greater than `max`.

## Url

**URL**: https://love1024.github.io/ngx-oneforall/validators/url
**Import**: `ngx-oneforall/validators/url`

`url` is a validator that ensures the control's value is a valid absolute URL string.

## Usage

Use `url` to validate that input values are valid URLs. It supports configuration for restricting protocols.

{{ NgDocActions.demo("UrlDemoComponent", { container: true }) }}

### Reactive Forms

```typescript
import { FormControl } from '@angular/forms';
import { url } from 'ngx-oneforall/validators/url';

const control = new FormControl(null, url({ protocols: ['https'] }));
```

### Template-Driven Forms (Directive)

You can use the `[url]` directive with template-driven forms. It accepts a `UrlValidatorOptions` object.

```html
<input type="text" [(ngModel)]="value" [url]="{ protocols: ['https'] }">
```

## API

`url(options: UrlValidatorOptions): ValidatorFn`

Options:
- `protocols?: readonly string[]`: List of allowed protocols (e.g., `['https', 'ftp']`). Only checked for absolute URLs.
- `skipProtocol?: boolean`: If `true`, allows URLs without a protocol scheme (e.g., `google.com`). Default `false`.

### Error Codes

| Reason | Description |
|--------|-------------|
| `invalid_format` | Value is not a valid URL |
| `invalid_protocol` | Protocol does not match allowed list |
| `unsupported_type` | Value is not a string |
